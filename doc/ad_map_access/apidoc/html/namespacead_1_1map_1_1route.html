<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ad_map_access: ad::map::route Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ad_map_access
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacead.html">ad</a></li><li class="navelem"><a class="el" href="namespacead_1_1map.html">map</a></li><li class="navelem"><a class="el" href="namespacead_1_1map_1_1route.html">route</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ad::map::route Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace route  
<a href="namespacead_1_1map_1_1route.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacead_1_1map_1_1route_1_1planning"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route_1_1planning.html">planning</a></td></tr>
<tr class="memdesc:namespacead_1_1map_1_1route_1_1planning"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace planning <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">ConnectingRoute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataType <a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html" title="DataType ConnectingRoute.">ConnectingRoute</a>.  <a href="structad_1_1map_1_1route_1_1ConnectingRoute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataType <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html" title="DataType FullRoute.">FullRoute</a>.  <a href="structad_1_1map_1_1route_1_1FullRoute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataType <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a>.  <a href="structad_1_1map_1_1route_1_1LaneInterval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad_1_1map_1_1route_1_1LaneSegment.html">LaneSegment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataType <a class="el" href="structad_1_1map_1_1route_1_1LaneSegment.html" title="DataType LaneSegment.">LaneSegment</a>.  <a href="structad_1_1map_1_1route_1_1LaneSegment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataType <a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html" title="DataType RoadSegment.">RoadSegment</a>.  <a href="structad_1_1map_1_1route_1_1RoadSegment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html">RouteParaPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataType <a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html" title="DataType RouteParaPoint.">RouteParaPoint</a>.  <a href="structad_1_1map_1_1route_1_1RouteParaPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad_1_1map_1_1route_1_1RouteIterator.html">RouteIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct defining iterator information on a route  <a href="structad_1_1map_1_1route_1_1RouteIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct defining the result type of <a class="el" href="namespacead_1_1map_1_1route.html#a296035ce0df0e63ee3dc2e3bb6bd7988" title="find a waypoint on the route containing the given position">findWaypoint()</a> and <a class="el" href="namespacead_1_1map_1_1route.html#a758674cc378d7ce72fb69e10030ffba2" title="find waypoint on the route containing the given positions">findNearestWaypoint()</a>  <a href="structad_1_1map_1_1route_1_1FindWaypointResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structad_1_1map_1_1route_1_1FindLaneChangeResult.html">FindLaneChangeResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct defining the result type of <a class="el" href="namespacead_1_1map_1_1route.html#ae650ab47205b04d82d1be2174c2e627b" title="finds the first route interval on a given route where a lane change is necessary to travel the given ...">findFirstLaneChange()</a>  <a href="structad_1_1map_1_1route_1_1FindLaneChangeResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7ad5dcc51516f086ed5a98b31914be53"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt;::<a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">ad::map::route::ConnectingRoute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a7ad5dcc51516f086ed5a98b31914be53">ConnectingRouteList</a></td></tr>
<tr class="memdesc:a7ad5dcc51516f086ed5a98b31914be53"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataType ConnectingRouteList.  <a href="namespacead_1_1map_1_1route.html#a7ad5dcc51516f086ed5a98b31914be53">More...</a><br /></td></tr>
<tr class="separator:a7ad5dcc51516f086ed5a98b31914be53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb86eafe66b8bfadd78ba5516e19ffe"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt;::<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">ad::map::route::FullRoute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a8cb86eafe66b8bfadd78ba5516e19ffe">FullRouteList</a></td></tr>
<tr class="memdesc:a8cb86eafe66b8bfadd78ba5516e19ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataType FullRouteList.  <a href="namespacead_1_1map_1_1route.html#a8cb86eafe66b8bfadd78ba5516e19ffe">More...</a><br /></td></tr>
<tr class="separator:a8cb86eafe66b8bfadd78ba5516e19ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af238c949adaf82d03c9edac92b60e054"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt;::<a class="el" href="structad_1_1map_1_1route_1_1LaneSegment.html">ad::map::route::LaneSegment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#af238c949adaf82d03c9edac92b60e054">LaneSegmentList</a></td></tr>
<tr class="memdesc:af238c949adaf82d03c9edac92b60e054"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataType LaneSegmentList.  <a href="namespacead_1_1map_1_1route.html#af238c949adaf82d03c9edac92b60e054">More...</a><br /></td></tr>
<tr class="separator:af238c949adaf82d03c9edac92b60e054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a23df4255ebcbd2b7be9b89d99f095"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt;::<a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">ad::map::route::RoadSegment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a83a23df4255ebcbd2b7be9b89d99f095">RoadSegmentList</a></td></tr>
<tr class="memdesc:a83a23df4255ebcbd2b7be9b89d99f095"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataType RoadSegmentList.  <a href="namespacead_1_1map_1_1route.html#a83a23df4255ebcbd2b7be9b89d99f095">More...</a><br /></td></tr>
<tr class="separator:a83a23df4255ebcbd2b7be9b89d99f095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf33d33b9c6c78ec77b2544c09021b6e"><td class="memItemLeft" align="right" valign="top">typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#adf33d33b9c6c78ec77b2544c09021b6e">RouteLaneOffset</a></td></tr>
<tr class="memdesc:adf33d33b9c6c78ec77b2544c09021b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataType RouteLaneOffset.  <a href="namespacead_1_1map_1_1route.html#adf33d33b9c6c78ec77b2544c09021b6e">More...</a><br /></td></tr>
<tr class="separator:adf33d33b9c6c78ec77b2544c09021b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17721e699ea11ccf5dfbb261d4d1623"><td class="memItemLeft" align="right" valign="top"><a id="ae17721e699ea11ccf5dfbb261d4d1623"></a>
typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ae17721e699ea11ccf5dfbb261d4d1623">RoutePlanningCounter</a></td></tr>
<tr class="memdesc:ae17721e699ea11ccf5dfbb261d4d1623"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataType RoutePlanningCounter. <br /></td></tr>
<tr class="separator:ae17721e699ea11ccf5dfbb261d4d1623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b421d8921da377162d82c18c438f88"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a71b421d8921da377162d82c18c438f88">SegmentCounter</a></td></tr>
<tr class="memdesc:a71b421d8921da377162d82c18c438f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataType SegmentCounter.  <a href="namespacead_1_1map_1_1route.html#a71b421d8921da377162d82c18c438f88">More...</a><br /></td></tr>
<tr class="separator:a71b421d8921da377162d82c18c438f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a19ef80d84e69ba2770b30d81e9029aa8"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a19ef80d84e69ba2770b30d81e9029aa8">ConnectingRouteType</a> : int32_t { <a class="el" href="namespacead_1_1map_1_1route.html#a19ef80d84e69ba2770b30d81e9029aa8a4bbb8f967da6d1a610596d7257179c2b">Invalid</a> = 0
, <a class="el" href="namespacead_1_1map_1_1route.html#a19ef80d84e69ba2770b30d81e9029aa8a6f796b0e6deb4f4c2c0ee0ed5e10e117">Following</a> = 1
, <a class="el" href="namespacead_1_1map_1_1route.html#a19ef80d84e69ba2770b30d81e9029aa8a0ef9a6968cfe92f7bde817483fb5d0cf">Opposing</a> = 2
, <a class="el" href="namespacead_1_1map_1_1route.html#a19ef80d84e69ba2770b30d81e9029aa8a76eaf4e29d18aa0bc8f10f646fc789bf">Merging</a> = 3
 }</td></tr>
<tr class="memdesc:a19ef80d84e69ba2770b30d81e9029aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataType ConnectingRouteType.  <a href="namespacead_1_1map_1_1route.html#a19ef80d84e69ba2770b30d81e9029aa8">More...</a><br /></td></tr>
<tr class="separator:a19ef80d84e69ba2770b30d81e9029aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab046615abf5d3c8c412d213a61670383"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ab046615abf5d3c8c412d213a61670383">LaneChangeDirection</a> : int32_t { <a class="el" href="namespacead_1_1map_1_1route.html#ab046615abf5d3c8c412d213a61670383ad1e80c506f4c89e3c4fb1c1b4867a03c">LeftToRight</a> = 0
, <a class="el" href="namespacead_1_1map_1_1route.html#ab046615abf5d3c8c412d213a61670383ab7b0ea3028791689ea070674776855e2">RightToLeft</a> = 1
, <a class="el" href="namespacead_1_1map_1_1route.html#ab046615abf5d3c8c412d213a61670383a4bbb8f967da6d1a610596d7257179c2b">Invalid</a> = 2
 }</td></tr>
<tr class="memdesc:ab046615abf5d3c8c412d213a61670383"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataType LaneChangeDirection.  <a href="namespacead_1_1map_1_1route.html#ab046615abf5d3c8c412d213a61670383">More...</a><br /></td></tr>
<tr class="separator:ab046615abf5d3c8c412d213a61670383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae9bcaf2936b1abe025aebd0fcbd77b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#aaae9bcaf2936b1abe025aebd0fcbd77b">RouteCreationMode</a> : int32_t { <a class="el" href="namespacead_1_1map_1_1route.html#aaae9bcaf2936b1abe025aebd0fcbd77baec0fc0100c4fc1ce4eea230c3dc10360">Undefined</a> = 0
, <a class="el" href="namespacead_1_1map_1_1route.html#aaae9bcaf2936b1abe025aebd0fcbd77bab51cd2c8724851ff796ff8cbb1cfa645">SameDrivingDirection</a> = 1
, <a class="el" href="namespacead_1_1map_1_1route.html#aaae9bcaf2936b1abe025aebd0fcbd77ba3078ff695395cfdd7f026a80ab57f514">AllRoutableLanes</a> = 2
, <a class="el" href="namespacead_1_1map_1_1route.html#aaae9bcaf2936b1abe025aebd0fcbd77ba8dce77e8132357431d06ebfbea96adb4">AllNeighborLanes</a> = 3
 }</td></tr>
<tr class="memdesc:aaae9bcaf2936b1abe025aebd0fcbd77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataType RouteCreationMode.  <a href="namespacead_1_1map_1_1route.html#aaae9bcaf2936b1abe025aebd0fcbd77b">More...</a><br /></td></tr>
<tr class="separator:aaae9bcaf2936b1abe025aebd0fcbd77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7061e80e6b9053968633f62a437e2822"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822">ShortenRouteResult</a> { <br />
&#160;&#160;<a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a66d02c2f8a582446f8dd8752366002b5">Succeeded</a>
, <a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a01553498d1f57420cbecd23a7405ee8c">SucceededBeforeRoute</a>
, <a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a4b0c532564b19e471cdc04ca7ba03c4c">SucceededRouteEmpty</a>
, <a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a0d9e48e4b3e799b4d6467ad3d48912cd">SucceededIntersectionNotCut</a>
, <br />
&#160;&#160;<a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a02740addb165a62ace58585fe7c8644d">FailedRouteEmpty</a>
<br />
 }</td></tr>
<tr class="memdesc:a7061e80e6b9053968633f62a437e2822"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration providing more insights into the actual shorten route result  <a href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822">More...</a><br /></td></tr>
<tr class="separator:a7061e80e6b9053968633f62a437e2822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ee85c81b9b35fd5a360e296480c670"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670">ShortenRouteMode</a> { <a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670a960b44c579bc2f6818d2daaf9e4c16f0">Normal</a>
, <a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670a5ec0697f06b6e0824b25d2aa2ddf811c">PrependIfSucceededBeforeRoute</a>
, <a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670acf85c0bbaa5860b429a47f3bc68d2991">DontCutIntersectionAndPrependIfSucceededBeforeRoute</a>
 }</td></tr>
<tr class="memdesc:a35ee85c81b9b35fd5a360e296480c670"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration defining the mode of operation of the <a class="el" href="namespacead_1_1map_1_1route.html#a610a706b502987b014c27d969e67f63a" title="follow the route by the given length">shortenRoute()</a> functions  <a href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670">More...</a><br /></td></tr>
<tr class="separator:a35ee85c81b9b35fd5a360e296480c670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5993e33e6ed864f1e1ad2a9eecbd14ec"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14ec">RouteSectionCreationMode</a> { <a class="el" href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14eca74984df073bdd6adc2d642e66956e1c3">SingleLane</a>
, <a class="el" href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14ecaef7d65c4d0ea0862c381bafe0bf7b040">AllRouteLanes</a>
 }</td></tr>
<tr class="memdesc:a5993e33e6ed864f1e1ad2a9eecbd14ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">the mode how the route section will be created  <a href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14ec">More...</a><br /></td></tr>
<tr class="separator:a5993e33e6ed864f1e1ad2a9eecbd14ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaded03d451bb5ec6e0a6a6a895d081de"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#aaded03d451bb5ec6e0a6a6a895d081de">ShortenRouteToDistanceMode</a> { <a class="el" href="namespacead_1_1map_1_1route.html#aaded03d451bb5ec6e0a6a6a895d081deaad20191b579063ba3dd57c9ae79fa74e">DontCutIntersection</a>
, <a class="el" href="namespacead_1_1map_1_1route.html#aaded03d451bb5ec6e0a6a6a895d081dea35cbd4d90ba828274d77f67eb0462c4d">AllowCutIntersection</a>
 }</td></tr>
<tr class="memdesc:aaded03d451bb5ec6e0a6a6a895d081de"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration defining the mode of operation of the <a class="el" href="namespacead_1_1map_1_1route.html#a4eabef74048da7168df8941310e5dede" title="shorten the route from the end to have at maximum the given length">shortenRouteToDistance()</a> function  <a href="namespacead_1_1map_1_1route.html#aaded03d451bb5ec6e0a6a6a895d081de">More...</a><br /></td></tr>
<tr class="separator:aaded03d451bb5ec6e0a6a6a895d081de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaf4e6cd1476293dc7a59b9e50f3cf565"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#aaf4e6cd1476293dc7a59b9e50f3cf565">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">ConnectingRoute</a> const &amp;_value)</td></tr>
<tr class="memdesc:aaf4e6cd1476293dc7a59b9e50f3cf565"><td class="mdescLeft">&#160;</td><td class="mdescRight">standard ostream operator  <a href="namespacead_1_1map_1_1route.html#aaf4e6cd1476293dc7a59b9e50f3cf565">More...</a><br /></td></tr>
<tr class="separator:aaf4e6cd1476293dc7a59b9e50f3cf565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ba080db4e287e95c1e881bba7cc984"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a91ba080db4e287e95c1e881bba7cc984">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespacead_1_1map_1_1route.html#a19ef80d84e69ba2770b30d81e9029aa8">ConnectingRouteType</a> const &amp;value)</td></tr>
<tr class="memdesc:a91ba080db4e287e95c1e881bba7cc984"><td class="mdescLeft">&#160;</td><td class="mdescRight">standard ostream operator  <a href="namespacead_1_1map_1_1route.html#a91ba080db4e287e95c1e881bba7cc984">More...</a><br /></td></tr>
<tr class="separator:a91ba080db4e287e95c1e881bba7cc984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace96c75c23a44e45465450e80ba1ee27"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ace96c75c23a44e45465450e80ba1ee27">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;_value)</td></tr>
<tr class="memdesc:ace96c75c23a44e45465450e80ba1ee27"><td class="mdescLeft">&#160;</td><td class="mdescRight">standard ostream operator  <a href="namespacead_1_1map_1_1route.html#ace96c75c23a44e45465450e80ba1ee27">More...</a><br /></td></tr>
<tr class="separator:ace96c75c23a44e45465450e80ba1ee27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89319989e9eedd5535289a918a3b17ac"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a89319989e9eedd5535289a918a3b17ac">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespacead_1_1map_1_1route.html#ab046615abf5d3c8c412d213a61670383">LaneChangeDirection</a> const &amp;value)</td></tr>
<tr class="memdesc:a89319989e9eedd5535289a918a3b17ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">standard ostream operator  <a href="namespacead_1_1map_1_1route.html#a89319989e9eedd5535289a918a3b17ac">More...</a><br /></td></tr>
<tr class="separator:a89319989e9eedd5535289a918a3b17ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8d23f814c6babd8cff3441d50d958a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#aec8d23f814c6babd8cff3441d50d958a">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;_value)</td></tr>
<tr class="memdesc:aec8d23f814c6babd8cff3441d50d958a"><td class="mdescLeft">&#160;</td><td class="mdescRight">standard ostream operator  <a href="namespacead_1_1map_1_1route.html#aec8d23f814c6babd8cff3441d50d958a">More...</a><br /></td></tr>
<tr class="separator:aec8d23f814c6babd8cff3441d50d958a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb1ae8d0fbf7d8a7cb2f4e86eba3c45"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a7bb1ae8d0fbf7d8a7cb2f4e86eba3c45">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="structad_1_1map_1_1route_1_1LaneSegment.html">LaneSegment</a> const &amp;_value)</td></tr>
<tr class="memdesc:a7bb1ae8d0fbf7d8a7cb2f4e86eba3c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">standard ostream operator  <a href="namespacead_1_1map_1_1route.html#a7bb1ae8d0fbf7d8a7cb2f4e86eba3c45">More...</a><br /></td></tr>
<tr class="separator:a7bb1ae8d0fbf7d8a7cb2f4e86eba3c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e3b9124637a8f4369539897aa0e588"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ab9e3b9124637a8f4369539897aa0e588">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;_value)</td></tr>
<tr class="memdesc:ab9e3b9124637a8f4369539897aa0e588"><td class="mdescLeft">&#160;</td><td class="mdescRight">standard ostream operator  <a href="namespacead_1_1map_1_1route.html#ab9e3b9124637a8f4369539897aa0e588">More...</a><br /></td></tr>
<tr class="separator:ab9e3b9124637a8f4369539897aa0e588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7f8bdbc65c906b47488f98df12fea4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a5f7f8bdbc65c906b47488f98df12fea4">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespacead_1_1map_1_1route.html#aaae9bcaf2936b1abe025aebd0fcbd77b">RouteCreationMode</a> const &amp;value)</td></tr>
<tr class="memdesc:a5f7f8bdbc65c906b47488f98df12fea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">standard ostream operator  <a href="namespacead_1_1map_1_1route.html#a5f7f8bdbc65c906b47488f98df12fea4">More...</a><br /></td></tr>
<tr class="separator:a5f7f8bdbc65c906b47488f98df12fea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf173775f54df387716dd67d404ccc9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a1bf173775f54df387716dd67d404ccc9">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html">RouteParaPoint</a> const &amp;_value)</td></tr>
<tr class="memdesc:a1bf173775f54df387716dd67d404ccc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">standard ostream operator  <a href="namespacead_1_1map_1_1route.html#a1bf173775f54df387716dd67d404ccc9">More...</a><br /></td></tr>
<tr class="separator:a1bf173775f54df387716dd67d404ccc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186883c51be80c6e1ddc48c94d8f4dc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a186883c51be80c6e1ddc48c94d8f4dc2">getIntervalStart</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a186883c51be80c6e1ddc48c94d8f4dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">class defining a route interval with one lane  <a href="namespacead_1_1map_1_1route.html#a186883c51be80c6e1ddc48c94d8f4dc2">More...</a><br /></td></tr>
<tr class="separator:a186883c51be80c6e1ddc48c94d8f4dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6bf193c6cb21a67afbb8638c0eee0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a8d6bf193c6cb21a67afbb8638c0eee0a">getIntervalStart</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;route, <a class="el" href="classad_1_1map_1_1lane_1_1LaneId.html">lane::LaneId</a> const &amp;lane_id)</td></tr>
<tr class="memdesc:a8d6bf193c6cb21a67afbb8638c0eee0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get interval start as ParaPoint for a given lane_id and a given route  <a href="namespacead_1_1map_1_1route.html#a8d6bf193c6cb21a67afbb8638c0eee0a">More...</a><br /></td></tr>
<tr class="separator:a8d6bf193c6cb21a67afbb8638c0eee0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb77679df8ca156905dd5532dc97179"><td class="memItemLeft" align="right" valign="top"><a id="a3eb77679df8ca156905dd5532dc97179"></a>
<a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a3eb77679df8ca156905dd5532dc97179">getIntervalEnd</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a3eb77679df8ca156905dd5532dc97179"><td class="mdescLeft">&#160;</td><td class="mdescRight">get interval end as ParaPoint <br /></td></tr>
<tr class="separator:a3eb77679df8ca156905dd5532dc97179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87c0c023f634eb87b4c433a770ef5c9"><td class="memItemLeft" align="right" valign="top"><a id="ad87c0c023f634eb87b4c433a770ef5c9"></a>
physics::ParametricRange&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ad87c0c023f634eb87b4c433a770ef5c9">toParametricRange</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">route::LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:ad87c0c023f634eb87b4c433a770ef5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert lane interval to ParametricRange <br /></td></tr>
<tr class="separator:ad87c0c023f634eb87b4c433a770ef5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a614593c9a3a4398ca241939a3fe93b"><td class="memItemLeft" align="right" valign="top">physics::ParametricValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a8a614593c9a3a4398ca241939a3fe93b">getSignedDistance</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;first, <a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;second)</td></tr>
<tr class="memdesc:a8a614593c9a3a4398ca241939a3fe93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the signed parametric physics::Distance between two parametric points respecting the lane_interval's direction  <a href="namespacead_1_1map_1_1route.html#a8a614593c9a3a4398ca241939a3fe93b">More...</a><br /></td></tr>
<tr class="separator:a8a614593c9a3a4398ca241939a3fe93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f0266324051ed94952734633231a4a"><td class="memItemLeft" align="right" valign="top">physics::ParametricValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a16f0266324051ed94952734633231a4a">getUnsignedDistance</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;first, <a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;second)</td></tr>
<tr class="memdesc:a16f0266324051ed94952734633231a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the unsigned parametric physics::Distance between two parametric points  <a href="namespacead_1_1map_1_1route.html#a16f0266324051ed94952734633231a4a">More...</a><br /></td></tr>
<tr class="separator:a16f0266324051ed94952734633231a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48949054ec50cd778d3c75c853180163"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a48949054ec50cd778d3c75c853180163">isStartOfInterval</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;point)</td></tr>
<tr class="memdesc:a48949054ec50cd778d3c75c853180163"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the point marks the start of the interval  <a href="namespacead_1_1map_1_1route.html#a48949054ec50cd778d3c75c853180163">More...</a><br /></td></tr>
<tr class="separator:a48949054ec50cd778d3c75c853180163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768a82ce9d96a1bfdc3516a57e87d915"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a768a82ce9d96a1bfdc3516a57e87d915">isEndOfInterval</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;point)</td></tr>
<tr class="memdesc:a768a82ce9d96a1bfdc3516a57e87d915"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the point marks the end of the interval  <a href="namespacead_1_1map_1_1route.html#a768a82ce9d96a1bfdc3516a57e87d915">More...</a><br /></td></tr>
<tr class="separator:a768a82ce9d96a1bfdc3516a57e87d915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad936d14bd3758e54aa5d5255d93a214e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ad936d14bd3758e54aa5d5255d93a214e">isRouteDirectionPositive</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:ad936d14bd3758e54aa5d5255d93a214e"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the direction of this route interval is positive in respect to the lane geometry  <a href="namespacead_1_1map_1_1route.html#ad936d14bd3758e54aa5d5255d93a214e">More...</a><br /></td></tr>
<tr class="separator:ad936d14bd3758e54aa5d5255d93a214e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbd5d17635b53d133ac3da20ae68bc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#affbd5d17635b53d133ac3da20ae68bc6">isRouteDirectionNegative</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:affbd5d17635b53d133ac3da20ae68bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the direction of this route interval is negative in respect to the lane geometry  <a href="namespacead_1_1map_1_1route.html#affbd5d17635b53d133ac3da20ae68bc6">More...</a><br /></td></tr>
<tr class="separator:affbd5d17635b53d133ac3da20ae68bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0f25ee09b898e3bd2f23364416c1e3"><td class="memItemLeft" align="right" valign="top"><a id="a1e0f25ee09b898e3bd2f23364416c1e3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a1e0f25ee09b898e3bd2f23364416c1e3">isRouteDirectionAlignedWithDrivingDirection</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a1e0f25ee09b898e3bd2f23364416c1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the route direction is aligned with the nominal driving direction of the lane <br /></td></tr>
<tr class="separator:a1e0f25ee09b898e3bd2f23364416c1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3a4c6dc5e9d4d8da2d12ab1057d482"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a3d3a4c6dc5e9d4d8da2d12ab1057d482">isWithinInterval</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, physics::ParametricValue const &amp;parametric_offset)</td></tr>
<tr class="memdesc:a3d3a4c6dc5e9d4d8da2d12ab1057d482"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the parametric offset is within the interval  <a href="namespacead_1_1map_1_1route.html#a3d3a4c6dc5e9d4d8da2d12ab1057d482">More...</a><br /></td></tr>
<tr class="separator:a3d3a4c6dc5e9d4d8da2d12ab1057d482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c00e1b6ae54389f870866725d852e43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a9c00e1b6ae54389f870866725d852e43">isWithinInterval</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;point)</td></tr>
<tr class="memdesc:a9c00e1b6ae54389f870866725d852e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the point is within the interval  <a href="namespacead_1_1map_1_1route.html#a9c00e1b6ae54389f870866725d852e43">More...</a><br /></td></tr>
<tr class="separator:a9c00e1b6ae54389f870866725d852e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b56d6c9116de25f143ffa162b7f0553"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a2b56d6c9116de25f143ffa162b7f0553">isDegenerated</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a2b56d6c9116de25f143ffa162b7f0553"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the interval is degenerated  <a href="namespacead_1_1map_1_1route.html#a2b56d6c9116de25f143ffa162b7f0553">More...</a><br /></td></tr>
<tr class="separator:a2b56d6c9116de25f143ffa162b7f0553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e09514926364ca1d27b3fad3c1e164"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a62e09514926364ca1d27b3fad3c1e164">isAfterInterval</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, physics::ParametricValue const parametric_offset)</td></tr>
<tr class="memdesc:a62e09514926364ca1d27b3fad3c1e164"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the parametric offset is after the interval  <a href="namespacead_1_1map_1_1route.html#a62e09514926364ca1d27b3fad3c1e164">More...</a><br /></td></tr>
<tr class="separator:a62e09514926364ca1d27b3fad3c1e164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d95666b3449f27c3f2660f0d4d8df9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ab8d95666b3449f27c3f2660f0d4d8df9">isAfterInterval</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;point)</td></tr>
<tr class="memdesc:ab8d95666b3449f27c3f2660f0d4d8df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the point is after the interval  <a href="namespacead_1_1map_1_1route.html#ab8d95666b3449f27c3f2660f0d4d8df9">More...</a><br /></td></tr>
<tr class="separator:ab8d95666b3449f27c3f2660f0d4d8df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6d1bead83c71d31d77d903c6ea374c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ace6d1bead83c71d31d77d903c6ea374c">isBeforeInterval</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, physics::ParametricValue const parametric_offset)</td></tr>
<tr class="memdesc:ace6d1bead83c71d31d77d903c6ea374c"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the parametric offset is before the interval  <a href="namespacead_1_1map_1_1route.html#ace6d1bead83c71d31d77d903c6ea374c">More...</a><br /></td></tr>
<tr class="separator:ace6d1bead83c71d31d77d903c6ea374c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8221e803c0f6a14b0c7ff97db6f29669"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a8221e803c0f6a14b0c7ff97db6f29669">isBeforeInterval</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;point)</td></tr>
<tr class="memdesc:a8221e803c0f6a14b0c7ff97db6f29669"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the point is before the interval  <a href="namespacead_1_1map_1_1route.html#a8221e803c0f6a14b0c7ff97db6f29669">More...</a><br /></td></tr>
<tr class="separator:a8221e803c0f6a14b0c7ff97db6f29669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94a3eb9d6dec5ca4aca73d2ae072683"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#af94a3eb9d6dec5ca4aca73d2ae072683">overlapsInterval</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, physics::ParametricRange const &amp;range)</td></tr>
<tr class="memdesc:af94a3eb9d6dec5ca4aca73d2ae072683"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the range overlaps with the interval  <a href="namespacead_1_1map_1_1route.html#af94a3eb9d6dec5ca4aca73d2ae072683">More...</a><br /></td></tr>
<tr class="separator:af94a3eb9d6dec5ca4aca73d2ae072683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6371094606526d93e480e3235d78b48d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a6371094606526d93e480e3235d78b48d">overlapsInterval</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;other)</td></tr>
<tr class="memdesc:a6371094606526d93e480e3235d78b48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the two lane intervals overlap with each other  <a href="namespacead_1_1map_1_1route.html#a6371094606526d93e480e3235d78b48d">More...</a><br /></td></tr>
<tr class="separator:a6371094606526d93e480e3235d78b48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50137f5732ad94fd2c954da527bed61f"><td class="memItemLeft" align="right" valign="top">physics::ParametricValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a50137f5732ad94fd2c954da527bed61f">getProjectedParametricOffsetOnNeighborLane</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;currentInterval, <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;neighborInterval, physics::ParametricValue const &amp;parametric_offset)</td></tr>
<tr class="memdesc:a50137f5732ad94fd2c954da527bed61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">project a given parametric position (offset) to the center line of the given neighbor lane  <a href="namespacead_1_1map_1_1route.html#a50137f5732ad94fd2c954da527bed61f">More...</a><br /></td></tr>
<tr class="separator:a50137f5732ad94fd2c954da527bed61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c9eab4a645b934e4ce29f9c752eb86"><td class="memItemLeft" align="right" valign="top"><a id="a00c9eab4a645b934e4ce29f9c752eb86"></a>
physics::ParametricValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a00c9eab4a645b934e4ce29f9c752eb86">calcParametricLength</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a00c9eab4a645b934e4ce29f9c752eb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the length of the provided lane interval as parametric value <br /></td></tr>
<tr class="separator:a00c9eab4a645b934e4ce29f9c752eb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d897db52931943339aa4df12e41f28d"><td class="memItemLeft" align="right" valign="top">physics::Distance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a5d897db52931943339aa4df12e41f28d">calcLength</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a5d897db52931943339aa4df12e41f28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the length of the provided lane interval as physics::Distance value  <a href="namespacead_1_1map_1_1route.html#a5d897db52931943339aa4df12e41f28d">More...</a><br /></td></tr>
<tr class="separator:a5d897db52931943339aa4df12e41f28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a355730845387c83f2372453dc4bd72"><td class="memItemLeft" align="right" valign="top">physics::Duration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a7a355730845387c83f2372453dc4bd72">calcDuration</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a7a355730845387c83f2372453dc4bd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the Duration of the provided lane interval as duration value  <a href="namespacead_1_1map_1_1route.html#a7a355730845387c83f2372453dc4bd72">More...</a><br /></td></tr>
<tr class="separator:a7a355730845387c83f2372453dc4bd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b03afc5d5a696f4eaaf15d3dd974c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#af5b03afc5d5a696f4eaaf15d3dd974c8">getRightEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1lane_1_1ENUEdge.html">lane::ENUEdge</a> &amp;enuEdge)</td></tr>
<tr class="memdesc:af5b03afc5d5a696f4eaaf15d3dd974c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">get right edge of the lane interval as ENUEdge  <a href="namespacead_1_1map_1_1route.html#af5b03afc5d5a696f4eaaf15d3dd974c8">More...</a><br /></td></tr>
<tr class="separator:af5b03afc5d5a696f4eaaf15d3dd974c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845213e4e5636a2a6670735951833b20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a845213e4e5636a2a6670735951833b20">getRightEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1lane_1_1ECEFEdge.html">lane::ECEFEdge</a> &amp;ecefEdge)</td></tr>
<tr class="memdesc:a845213e4e5636a2a6670735951833b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">get right edge of the lane interval as ECEFEdge  <a href="namespacead_1_1map_1_1route.html#a845213e4e5636a2a6670735951833b20">More...</a><br /></td></tr>
<tr class="separator:a845213e4e5636a2a6670735951833b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6819a9e97c8905b61a5fd1b450ab092d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a6819a9e97c8905b61a5fd1b450ab092d">getRightEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1lane_1_1GeoEdge.html">lane::GeoEdge</a> &amp;geoEdge)</td></tr>
<tr class="memdesc:a6819a9e97c8905b61a5fd1b450ab092d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get right edge of the lane interval as GeoEdge  <a href="namespacead_1_1map_1_1route.html#a6819a9e97c8905b61a5fd1b450ab092d">More...</a><br /></td></tr>
<tr class="separator:a6819a9e97c8905b61a5fd1b450ab092d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b8e3bea8053ba7f5e713126534db64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1ENUEdge.html">lane::ENUEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#af8b8e3bea8053ba7f5e713126534db64">getRightENUEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:af8b8e3bea8053ba7f5e713126534db64"><td class="mdescLeft">&#160;</td><td class="mdescRight">get right edge of the lane interval as ENUEdge  <a href="namespacead_1_1map_1_1route.html#af8b8e3bea8053ba7f5e713126534db64">More...</a><br /></td></tr>
<tr class="separator:af8b8e3bea8053ba7f5e713126534db64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ae0dfabf5969005a0fe3ec6f8f24ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1ECEFEdge.html">lane::ECEFEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a45ae0dfabf5969005a0fe3ec6f8f24ef">getRightECEFEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a45ae0dfabf5969005a0fe3ec6f8f24ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">get right edge of the lane interval as ECEFEdge  <a href="namespacead_1_1map_1_1route.html#a45ae0dfabf5969005a0fe3ec6f8f24ef">More...</a><br /></td></tr>
<tr class="separator:a45ae0dfabf5969005a0fe3ec6f8f24ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5b5e91ec1c2f554675e3c85ebf1252"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1GeoEdge.html">lane::GeoEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a8c5b5e91ec1c2f554675e3c85ebf1252">getRightGeoEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a8c5b5e91ec1c2f554675e3c85ebf1252"><td class="mdescLeft">&#160;</td><td class="mdescRight">get right edge of the lane interval as GeoEdge  <a href="namespacead_1_1map_1_1route.html#a8c5b5e91ec1c2f554675e3c85ebf1252">More...</a><br /></td></tr>
<tr class="separator:a8c5b5e91ec1c2f554675e3c85ebf1252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901be85a1d048210ef27de1c1b212970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a901be85a1d048210ef27de1c1b212970">getRightProjectedEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1lane_1_1ENUEdge.html">lane::ENUEdge</a> &amp;enuEdge)</td></tr>
<tr class="memdesc:a901be85a1d048210ef27de1c1b212970"><td class="mdescLeft">&#160;</td><td class="mdescRight">get right edge of the lane interval as ENUEdge using projection to find the start of the edge  <a href="namespacead_1_1map_1_1route.html#a901be85a1d048210ef27de1c1b212970">More...</a><br /></td></tr>
<tr class="separator:a901be85a1d048210ef27de1c1b212970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae032fd4d27dd29dbfc0280d9e5e8f531"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ae032fd4d27dd29dbfc0280d9e5e8f531">getRightProjectedEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1lane_1_1ECEFEdge.html">lane::ECEFEdge</a> &amp;ecefEdge)</td></tr>
<tr class="memdesc:ae032fd4d27dd29dbfc0280d9e5e8f531"><td class="mdescLeft">&#160;</td><td class="mdescRight">get right edge of the lane interval as ECEFEdge using projection to find the start of the edge  <a href="namespacead_1_1map_1_1route.html#ae032fd4d27dd29dbfc0280d9e5e8f531">More...</a><br /></td></tr>
<tr class="separator:ae032fd4d27dd29dbfc0280d9e5e8f531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c832ee5be74b3430dd9f25780096bd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a6c832ee5be74b3430dd9f25780096bd4">getRightProjectedEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1lane_1_1GeoEdge.html">lane::GeoEdge</a> &amp;geoEdge)</td></tr>
<tr class="memdesc:a6c832ee5be74b3430dd9f25780096bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">get right edge of the lane interval as GeoEdge using projection to find the start of the edge  <a href="namespacead_1_1map_1_1route.html#a6c832ee5be74b3430dd9f25780096bd4">More...</a><br /></td></tr>
<tr class="separator:a6c832ee5be74b3430dd9f25780096bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890ecbc7c9ce9eae16d2d8b43fb00af2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1ENUEdge.html">lane::ENUEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a890ecbc7c9ce9eae16d2d8b43fb00af2">getRightProjectedENUEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a890ecbc7c9ce9eae16d2d8b43fb00af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">get right edge of the lane interval as ENUEdge using projection to find the start of the edge  <a href="namespacead_1_1map_1_1route.html#a890ecbc7c9ce9eae16d2d8b43fb00af2">More...</a><br /></td></tr>
<tr class="separator:a890ecbc7c9ce9eae16d2d8b43fb00af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f3fae38f9140acb92b961f8eddfb64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1ECEFEdge.html">lane::ECEFEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#aa1f3fae38f9140acb92b961f8eddfb64">getRightProjectedECEFEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:aa1f3fae38f9140acb92b961f8eddfb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">get right edge of the lane interval as ECEFEdge using projection to find the start of the edge  <a href="namespacead_1_1map_1_1route.html#aa1f3fae38f9140acb92b961f8eddfb64">More...</a><br /></td></tr>
<tr class="separator:aa1f3fae38f9140acb92b961f8eddfb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad147581cc5434aaffb437c9509f4b69a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1GeoEdge.html">lane::GeoEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ad147581cc5434aaffb437c9509f4b69a">getRightProjectedGeoEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:ad147581cc5434aaffb437c9509f4b69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get right edge of the lane interval as GeoEdge using projection to find the start of the edge  <a href="namespacead_1_1map_1_1route.html#ad147581cc5434aaffb437c9509f4b69a">More...</a><br /></td></tr>
<tr class="separator:ad147581cc5434aaffb437c9509f4b69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02627cba57de68234a304193dca5a79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#af02627cba57de68234a304193dca5a79">getLeftEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1lane_1_1ENUEdge.html">lane::ENUEdge</a> &amp;enuEdge)</td></tr>
<tr class="memdesc:af02627cba57de68234a304193dca5a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">get Left edge of the lane interval as ENUEdge  <a href="namespacead_1_1map_1_1route.html#af02627cba57de68234a304193dca5a79">More...</a><br /></td></tr>
<tr class="separator:af02627cba57de68234a304193dca5a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537b3772998ed31950e14480be707ee8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a537b3772998ed31950e14480be707ee8">getLeftEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1lane_1_1ECEFEdge.html">lane::ECEFEdge</a> &amp;ecefEdge)</td></tr>
<tr class="memdesc:a537b3772998ed31950e14480be707ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">get Left edge of the lane interval as ECEFEdge  <a href="namespacead_1_1map_1_1route.html#a537b3772998ed31950e14480be707ee8">More...</a><br /></td></tr>
<tr class="separator:a537b3772998ed31950e14480be707ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b08cf2f803577f89fd0d71d86da35f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a5b08cf2f803577f89fd0d71d86da35f9">getLeftEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1lane_1_1GeoEdge.html">lane::GeoEdge</a> &amp;geoEdge)</td></tr>
<tr class="memdesc:a5b08cf2f803577f89fd0d71d86da35f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">get Left edge of the lane interval as GeoEdge  <a href="namespacead_1_1map_1_1route.html#a5b08cf2f803577f89fd0d71d86da35f9">More...</a><br /></td></tr>
<tr class="separator:a5b08cf2f803577f89fd0d71d86da35f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe1295f8b412c2221f21b0b1d007d3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1ENUEdge.html">lane::ENUEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#abfe1295f8b412c2221f21b0b1d007d3c">getLeftENUEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:abfe1295f8b412c2221f21b0b1d007d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">get left edge of the lane interval as ENUEdge  <a href="namespacead_1_1map_1_1route.html#abfe1295f8b412c2221f21b0b1d007d3c">More...</a><br /></td></tr>
<tr class="separator:abfe1295f8b412c2221f21b0b1d007d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2dcf35500e9356855d71c7746a744e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1ECEFEdge.html">lane::ECEFEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#afa2dcf35500e9356855d71c7746a744e">getLeftECEFEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:afa2dcf35500e9356855d71c7746a744e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get left edge of the lane interval as ECEFEdge  <a href="namespacead_1_1map_1_1route.html#afa2dcf35500e9356855d71c7746a744e">More...</a><br /></td></tr>
<tr class="separator:afa2dcf35500e9356855d71c7746a744e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12440227edad60b5d8dce510f0289257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1GeoEdge.html">lane::GeoEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a12440227edad60b5d8dce510f0289257">getLeftGeoEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a12440227edad60b5d8dce510f0289257"><td class="mdescLeft">&#160;</td><td class="mdescRight">get left edge of the lane interval as GeoEdge  <a href="namespacead_1_1map_1_1route.html#a12440227edad60b5d8dce510f0289257">More...</a><br /></td></tr>
<tr class="separator:a12440227edad60b5d8dce510f0289257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9831b1f4d7bee73f71420ae5a61b4202"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a9831b1f4d7bee73f71420ae5a61b4202">getLeftProjectedEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1lane_1_1ENUEdge.html">lane::ENUEdge</a> &amp;enuEdge)</td></tr>
<tr class="memdesc:a9831b1f4d7bee73f71420ae5a61b4202"><td class="mdescLeft">&#160;</td><td class="mdescRight">get Left edge of the lane interval as ENUEdge using projection to find the start of the edge  <a href="namespacead_1_1map_1_1route.html#a9831b1f4d7bee73f71420ae5a61b4202">More...</a><br /></td></tr>
<tr class="separator:a9831b1f4d7bee73f71420ae5a61b4202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edc96cca8f06d57deb0eaafb098aa3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a4edc96cca8f06d57deb0eaafb098aa3f">getLeftProjectedEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1lane_1_1ECEFEdge.html">lane::ECEFEdge</a> &amp;ecefEdge)</td></tr>
<tr class="memdesc:a4edc96cca8f06d57deb0eaafb098aa3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get Left edge of the lane interval as ECEFEdge using projection to find the start of the edge  <a href="namespacead_1_1map_1_1route.html#a4edc96cca8f06d57deb0eaafb098aa3f">More...</a><br /></td></tr>
<tr class="separator:a4edc96cca8f06d57deb0eaafb098aa3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e92a8d9c2c8e2429def8a41654b2088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a5e92a8d9c2c8e2429def8a41654b2088">getLeftProjectedEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1lane_1_1GeoEdge.html">lane::GeoEdge</a> &amp;geoEdge)</td></tr>
<tr class="memdesc:a5e92a8d9c2c8e2429def8a41654b2088"><td class="mdescLeft">&#160;</td><td class="mdescRight">get Left edge of the lane interval as GeoEdge using projection to find the start of the edge  <a href="namespacead_1_1map_1_1route.html#a5e92a8d9c2c8e2429def8a41654b2088">More...</a><br /></td></tr>
<tr class="separator:a5e92a8d9c2c8e2429def8a41654b2088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dc6f9c4221e3c5cda9753919a9347b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1ENUEdge.html">lane::ENUEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#af0dc6f9c4221e3c5cda9753919a9347b">getLeftProjectedENUEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:af0dc6f9c4221e3c5cda9753919a9347b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get left edge of the lane interval as ENUEdge using projection to find the start of the edge  <a href="namespacead_1_1map_1_1route.html#af0dc6f9c4221e3c5cda9753919a9347b">More...</a><br /></td></tr>
<tr class="separator:af0dc6f9c4221e3c5cda9753919a9347b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134e5cdd7edf541b2718bf43795f81b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1ECEFEdge.html">lane::ECEFEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a134e5cdd7edf541b2718bf43795f81b1">getLeftProjectedECEFEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a134e5cdd7edf541b2718bf43795f81b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">get left edge of the lane interval as ECEFEdge using projection to find the start of the edge  <a href="namespacead_1_1map_1_1route.html#a134e5cdd7edf541b2718bf43795f81b1">More...</a><br /></td></tr>
<tr class="separator:a134e5cdd7edf541b2718bf43795f81b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888e887f4b317d5095730d579169ae84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1GeoEdge.html">lane::GeoEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a888e887f4b317d5095730d579169ae84">getLeftProjectedGeoEdge</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a888e887f4b317d5095730d579169ae84"><td class="mdescLeft">&#160;</td><td class="mdescRight">get left edge of the lane interval as GeoEdge using projection to find the start of the edge  <a href="namespacead_1_1map_1_1route.html#a888e887f4b317d5095730d579169ae84">More...</a><br /></td></tr>
<tr class="separator:a888e887f4b317d5095730d579169ae84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5359d31e460b4e308e2053449b106089"><td class="memItemLeft" align="right" valign="top"><a id="a5359d31e460b4e308e2053449b106089"></a>
<a class="el" href="structad_1_1map_1_1lane_1_1GeoBorder.html">lane::GeoBorder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a5359d31e460b4e308e2053449b106089">getGeoBorder</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a5359d31e460b4e308e2053449b106089"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the geo borders of this lane <br /></td></tr>
<tr class="separator:a5359d31e460b4e308e2053449b106089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa667b0c36d6df3c2a123ad9539e58eb5"><td class="memItemLeft" align="right" valign="top"><a id="aa667b0c36d6df3c2a123ad9539e58eb5"></a>
<a class="el" href="structad_1_1map_1_1lane_1_1ECEFBorder.html">lane::ECEFBorder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#aa667b0c36d6df3c2a123ad9539e58eb5">getECEFBorder</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:aa667b0c36d6df3c2a123ad9539e58eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the ecef borders of this lane <br /></td></tr>
<tr class="separator:aa667b0c36d6df3c2a123ad9539e58eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60a4c4f63e8cae13ffc24207a229ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1ENUBorder.html">lane::ENUBorder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ac60a4c4f63e8cae13ffc24207a229ab7">getENUBorder</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:ac60a4c4f63e8cae13ffc24207a229ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the enu borders of this lane  <a href="namespacead_1_1map_1_1route.html#ac60a4c4f63e8cae13ffc24207a229ab7">More...</a><br /></td></tr>
<tr class="separator:ac60a4c4f63e8cae13ffc24207a229ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8fd91b30c7a4ee2c14da6d208a2e72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1ENUBorder.html">lane::ENUBorder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a2f8fd91b30c7a4ee2c14da6d208a2e72">getENUProjectedBorder</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a2f8fd91b30c7a4ee2c14da6d208a2e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the enu borders of this lane  <a href="namespacead_1_1map_1_1route.html#a2f8fd91b30c7a4ee2c14da6d208a2e72">More...</a><br /></td></tr>
<tr class="separator:a2f8fd91b30c7a4ee2c14da6d208a2e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9514a567c48c09bd3e9402a20e463827"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a9514a567c48c09bd3e9402a20e463827">shortenIntervalFromBegin</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, physics::Distance const &amp;distance)</td></tr>
<tr class="memdesc:a9514a567c48c09bd3e9402a20e463827"><td class="mdescLeft">&#160;</td><td class="mdescRight">shorten the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> about a given physics::Distance. Will remove at the begin of the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a>  <a href="namespacead_1_1map_1_1route.html#a9514a567c48c09bd3e9402a20e463827">More...</a><br /></td></tr>
<tr class="separator:a9514a567c48c09bd3e9402a20e463827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3675ff33b7eef11d5d96312d827a027"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ad3675ff33b7eef11d5d96312d827a027">shortenIntervalFromEnd</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, physics::Distance const &amp;distance)</td></tr>
<tr class="memdesc:ad3675ff33b7eef11d5d96312d827a027"><td class="mdescLeft">&#160;</td><td class="mdescRight">shorten the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> about a given physics::Distance. Will remove at the end of the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a>  <a href="namespacead_1_1map_1_1route.html#ad3675ff33b7eef11d5d96312d827a027">More...</a><br /></td></tr>
<tr class="separator:ad3675ff33b7eef11d5d96312d827a027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0b1ec8e08ec519f70e0eb31a9be14d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#aae0b1ec8e08ec519f70e0eb31a9be14d">restrictIntervalFromBegin</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, physics::Distance const &amp;distance)</td></tr>
<tr class="memdesc:aae0b1ec8e08ec519f70e0eb31a9be14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restrict length of the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> to a given physics::Distance from start.  <a href="namespacead_1_1map_1_1route.html#aae0b1ec8e08ec519f70e0eb31a9be14d">More...</a><br /></td></tr>
<tr class="separator:aae0b1ec8e08ec519f70e0eb31a9be14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7a71f88fa626a513f351ea5e077f74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a0a7a71f88fa626a513f351ea5e077f74">extendIntervalUntilEnd</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a0a7a71f88fa626a513f351ea5e077f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">extend the lane interval until the end of the lane reached  <a href="namespacead_1_1map_1_1route.html#a0a7a71f88fa626a513f351ea5e077f74">More...</a><br /></td></tr>
<tr class="separator:a0a7a71f88fa626a513f351ea5e077f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cb4b5775c434a270750cc447c86033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a69cb4b5775c434a270750cc447c86033">cutIntervalAtStart</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, physics::ParametricValue const &amp;newIntervalStart)</td></tr>
<tr class="memdesc:a69cb4b5775c434a270750cc447c86033"><td class="mdescLeft">&#160;</td><td class="mdescRight">cut the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> at a given parametric point. Will remove at the start of the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a>  <a href="namespacead_1_1map_1_1route.html#a69cb4b5775c434a270750cc447c86033">More...</a><br /></td></tr>
<tr class="separator:a69cb4b5775c434a270750cc447c86033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6956151942f031ba1262987033ff2b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ac6956151942f031ba1262987033ff2b0">extendIntervalUntilStart</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:ac6956151942f031ba1262987033ff2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">extend the lane interval until the start of the lane reached  <a href="namespacead_1_1map_1_1route.html#ac6956151942f031ba1262987033ff2b0">More...</a><br /></td></tr>
<tr class="separator:ac6956151942f031ba1262987033ff2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8ecd32439e435ba083ddeb4f19fba1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#aad8ecd32439e435ba083ddeb4f19fba1">extendIntervalFromStart</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, physics::Distance const &amp;distance)</td></tr>
<tr class="memdesc:aad8ecd32439e435ba083ddeb4f19fba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">extend the lane interval by moving its start position by physics::Distance  <a href="namespacead_1_1map_1_1route.html#aad8ecd32439e435ba083ddeb4f19fba1">More...</a><br /></td></tr>
<tr class="separator:aad8ecd32439e435ba083ddeb4f19fba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63b642930ef0f7288e2cd202999811e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ad63b642930ef0f7288e2cd202999811e">extendIntervalFromEnd</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, physics::Distance const &amp;distance)</td></tr>
<tr class="memdesc:ad63b642930ef0f7288e2cd202999811e"><td class="mdescLeft">&#160;</td><td class="mdescRight">extend the lane interval by moving its end position by physics::Distance  <a href="namespacead_1_1map_1_1route.html#ad63b642930ef0f7288e2cd202999811e">More...</a><br /></td></tr>
<tr class="separator:ad63b642930ef0f7288e2cd202999811e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6f2e9771b978392f228b95357ba319"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a0d6f2e9771b978392f228b95357ba319">cutIntervalAtEnd</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, physics::ParametricValue const &amp;newIntervalEnd)</td></tr>
<tr class="memdesc:a0d6f2e9771b978392f228b95357ba319"><td class="mdescLeft">&#160;</td><td class="mdescRight">cut the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> at a given parametric point. Will remove at the end of the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a>  <a href="namespacead_1_1map_1_1route.html#a0d6f2e9771b978392f228b95357ba319">More...</a><br /></td></tr>
<tr class="separator:a0d6f2e9771b978392f228b95357ba319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1831fff568d45a2100c0f172b78c66"><td class="memItemLeft" align="right" valign="top"><a id="a0f1831fff568d45a2100c0f172b78c66"></a>
<a class="el" href="namespacead_1_1map_1_1restriction.html#a2e3c5cd0313717504de387a0e0ea272b">restriction::SpeedLimitList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a0f1831fff568d45a2100c0f172b78c66">getSpeedLimits</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:a0f1831fff568d45a2100c0f172b78c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the speed limits of the lane interval <br /></td></tr>
<tr class="separator:a0f1831fff568d45a2100c0f172b78c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea589c1ea13821ebdfa84eff2ebabf5"><td class="memItemLeft" align="right" valign="top"><a id="a6ea589c1ea13821ebdfa84eff2ebabf5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a6ea589c1ea13821ebdfa84eff2ebabf5">getMetricRanges</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;lane_interval, physics::MetricRange &amp;length_range, physics::MetricRange &amp;width_range)</td></tr>
<tr class="memdesc:a6ea589c1ea13821ebdfa84eff2ebabf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the metric ranges of the lane interval <br /></td></tr>
<tr class="separator:a6ea589c1ea13821ebdfa84eff2ebabf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8553cd7f33ea9187575277ad411fae4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1RouteIterator.html">RouteIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a8553cd7f33ea9187575277ad411fae4a">getRouteIterator</a> (<a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html">route::RouteParaPoint</a> const &amp;routePosition, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route)</td></tr>
<tr class="memdesc:a8553cd7f33ea9187575277ad411fae4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the route iterator from a given route position  <a href="namespacead_1_1map_1_1route.html#a8553cd7f33ea9187575277ad411fae4a">More...</a><br /></td></tr>
<tr class="separator:a8553cd7f33ea9187575277ad411fae4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93bc20be3049b172aaad13218ed9166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ae93bc20be3049b172aaad13218ed9166">getLaneParaPoint</a> (physics::ParametricValue const &amp;routeParametricOffset, <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">route::LaneInterval</a> const &amp;lane_interval)</td></tr>
<tr class="memdesc:ae93bc20be3049b172aaad13218ed9166"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the lane para points in respect to the given route parametric offset  <a href="namespacead_1_1map_1_1route.html#ae93bc20be3049b172aaad13218ed9166">More...</a><br /></td></tr>
<tr class="separator:ae93bc20be3049b172aaad13218ed9166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f2304ab78c97755c0c30c86ebef929"><td class="memItemLeft" align="right" valign="top">physics::Distance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a07f2304ab78c97755c0c30c86ebef929">signedDistanceToLane</a> (<a class="el" href="classad_1_1map_1_1lane_1_1LaneId.html">lane::LaneId</a> const &amp;checkLaneId, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;route, <a class="el" href="namespacead_1_1map_1_1match.html#aaed86807265fc30096de4c1e809f715c">match::MapMatchedPositionConfidenceList</a> const &amp;mapMatchedPositions)</td></tr>
<tr class="memdesc:a07f2304ab78c97755c0c30c86ebef929"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the signed distance to a lane w.r.t to a given route (direction) for the map matched positions  <a href="namespacead_1_1map_1_1route.html#a07f2304ab78c97755c0c30c86ebef929">More...</a><br /></td></tr>
<tr class="separator:a07f2304ab78c97755c0c30c86ebef929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2678f9b71224d0fb33899237647b3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacead_1_1map_1_1point.html#a61ca5a48026fe858c1f9db0167256fda">point::ParaPointList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#aae2678f9b71224d0fb33899237647b3c">getLaneParaPoints</a> (<a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html">route::RouteParaPoint</a> const &amp;routePosition, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route)</td></tr>
<tr class="memdesc:aae2678f9b71224d0fb33899237647b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the lane para points in respect to the given route position  <a href="namespacead_1_1map_1_1route.html#aae2678f9b71224d0fb33899237647b3c">More...</a><br /></td></tr>
<tr class="separator:aae2678f9b71224d0fb33899237647b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d432e466fe7ad66620a296cb0c0d632"><td class="memItemLeft" align="right" valign="top"><a id="a6d432e466fe7ad66620a296cb0c0d632"></a>
physics::Distance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a6d432e466fe7ad66620a296cb0c0d632">calcLength</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;fullRoute)</td></tr>
<tr class="memdesc:a6d432e466fe7ad66620a296cb0c0d632"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the length of the provided full route <br /></td></tr>
<tr class="separator:a6d432e466fe7ad66620a296cb0c0d632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117edffb03b1913a0724ebaa382f6984"><td class="memItemLeft" align="right" valign="top">physics::Distance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a117edffb03b1913a0724ebaa382f6984">calcLength</a> (<a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;roadSegment)</td></tr>
<tr class="memdesc:a117edffb03b1913a0724ebaa382f6984"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the length of the provided road segment  <a href="namespacead_1_1map_1_1route.html#a117edffb03b1913a0724ebaa382f6984">More...</a><br /></td></tr>
<tr class="separator:a117edffb03b1913a0724ebaa382f6984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e596fe6c9566452507ab5b48db0fb86"><td class="memItemLeft" align="right" valign="top"><a id="a0e596fe6c9566452507ab5b48db0fb86"></a>
physics::Distance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a0e596fe6c9566452507ab5b48db0fb86">calcLength</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneSegment.html">LaneSegment</a> const &amp;laneSegment)</td></tr>
<tr class="memdesc:a0e596fe6c9566452507ab5b48db0fb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the length of the provided lane segment <br /></td></tr>
<tr class="separator:a0e596fe6c9566452507ab5b48db0fb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec409a8db10c3fbdc98b94f844451a2"><td class="memItemLeft" align="right" valign="top">physics::Distance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#aeec409a8db10c3fbdc98b94f844451a2">calcLength</a> (<a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">ConnectingRoute</a> const &amp;connectingRoute)</td></tr>
<tr class="memdesc:aeec409a8db10c3fbdc98b94f844451a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the length of the provided connecting route  <a href="namespacead_1_1map_1_1route.html#aeec409a8db10c3fbdc98b94f844451a2">More...</a><br /></td></tr>
<tr class="separator:aeec409a8db10c3fbdc98b94f844451a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f894070263f9da4912493f944e3e27b"><td class="memItemLeft" align="right" valign="top"><a id="a1f894070263f9da4912493f944e3e27b"></a>
physics::Distance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a1f894070263f9da4912493f944e3e27b">calcLength</a> (<a class="el" href="structad_1_1map_1_1route_1_1RouteIterator.html">RouteIterator</a> const &amp;startIterator, <a class="el" href="structad_1_1map_1_1route_1_1RouteIterator.html">RouteIterator</a> const &amp;endIterator)</td></tr>
<tr class="memdesc:a1f894070263f9da4912493f944e3e27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the length between the two given iterators <br /></td></tr>
<tr class="separator:a1f894070263f9da4912493f944e3e27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27c28f5d4be05cdaf533c522cca89cf"><td class="memItemLeft" align="right" valign="top"><a id="ac27c28f5d4be05cdaf533c522cca89cf"></a>
physics::Distance&#160;</td><td class="memItemRight" valign="bottom"><b>calcLength</b> (<a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html">RouteParaPoint</a> const &amp;startRouteParaPoint, <a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html">RouteParaPoint</a> const &amp;endRouteParaPoint, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;route)</td></tr>
<tr class="separator:ac27c28f5d4be05cdaf533c522cca89cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8557854477f0ec372af90bb66b583b"><td class="memItemLeft" align="right" valign="top"><a id="a5f8557854477f0ec372af90bb66b583b"></a>
physics::Duration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a5f8557854477f0ec372af90bb66b583b">calcDuration</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;fullRoute)</td></tr>
<tr class="memdesc:a5f8557854477f0ec372af90bb66b583b"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the Duration of the provided full route <br /></td></tr>
<tr class="separator:a5f8557854477f0ec372af90bb66b583b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0005a3e14162156e5ea973ed2c686f7f"><td class="memItemLeft" align="right" valign="top">physics::Duration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a0005a3e14162156e5ea973ed2c686f7f">calcDuration</a> (<a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;roadSegment)</td></tr>
<tr class="memdesc:a0005a3e14162156e5ea973ed2c686f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the Duration of the provided road segment  <a href="namespacead_1_1map_1_1route.html#a0005a3e14162156e5ea973ed2c686f7f">More...</a><br /></td></tr>
<tr class="separator:a0005a3e14162156e5ea973ed2c686f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407032132648f435133972d6d86e8789"><td class="memItemLeft" align="right" valign="top"><a id="a407032132648f435133972d6d86e8789"></a>
physics::Duration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a407032132648f435133972d6d86e8789">calcDuration</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneSegment.html">LaneSegment</a> const &amp;laneSegment)</td></tr>
<tr class="memdesc:a407032132648f435133972d6d86e8789"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the Duration of the provided lane segment <br /></td></tr>
<tr class="separator:a407032132648f435133972d6d86e8789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8094fa0d77e8f63f243bbbe0197a58"><td class="memItemLeft" align="right" valign="top">physics::Duration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a7e8094fa0d77e8f63f243bbbe0197a58">calcDuration</a> (<a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">ConnectingRoute</a> const &amp;connectingRoute)</td></tr>
<tr class="memdesc:a7e8094fa0d77e8f63f243bbbe0197a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the Duration of the provided connecting route  <a href="namespacead_1_1map_1_1route.html#a7e8094fa0d77e8f63f243bbbe0197a58">More...</a><br /></td></tr>
<tr class="separator:a7e8094fa0d77e8f63f243bbbe0197a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04755122d096903972e443eaf1a038d7"><td class="memItemLeft" align="right" valign="top"><a id="a04755122d096903972e443eaf1a038d7"></a>
<a class="el" href="namespacead_1_1map_1_1restriction.html#a2e3c5cd0313717504de387a0e0ea272b">restriction::SpeedLimitList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a04755122d096903972e443eaf1a038d7">getSpeedLimits</a> (<a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;roadSegment)</td></tr>
<tr class="memdesc:a04755122d096903972e443eaf1a038d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the speed limits of the road segment <br /></td></tr>
<tr class="separator:a04755122d096903972e443eaf1a038d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b652f2b9a8bec16b3d859d8b2e8f763"><td class="memItemLeft" align="right" valign="top"><a id="a8b652f2b9a8bec16b3d859d8b2e8f763"></a>
<a class="el" href="namespacead_1_1map_1_1restriction.html#a2e3c5cd0313717504de387a0e0ea272b">restriction::SpeedLimitList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a8b652f2b9a8bec16b3d859d8b2e8f763">getSpeedLimits</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneSegment.html">LaneSegment</a> const &amp;laneSegment)</td></tr>
<tr class="memdesc:a8b652f2b9a8bec16b3d859d8b2e8f763"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the speed limits of the lane segment <br /></td></tr>
<tr class="separator:a8b652f2b9a8bec16b3d859d8b2e8f763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50303295ee71047b0dbf2c2b1d727ac3"><td class="memItemLeft" align="right" valign="top"><a id="a50303295ee71047b0dbf2c2b1d727ac3"></a>
<a class="el" href="namespacead_1_1map_1_1restriction.html#a2e3c5cd0313717504de387a0e0ea272b">restriction::SpeedLimitList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a50303295ee71047b0dbf2c2b1d727ac3">getSpeedLimits</a> (<a class="el" href="structad_1_1map_1_1route_1_1RouteIterator.html">RouteIterator</a> const &amp;startIterator, <a class="el" href="structad_1_1map_1_1route_1_1RouteIterator.html">RouteIterator</a> const &amp;endIterator)</td></tr>
<tr class="memdesc:a50303295ee71047b0dbf2c2b1d727ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the speed limits between the two given iterators <br /></td></tr>
<tr class="separator:a50303295ee71047b0dbf2c2b1d727ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2eb23a4dbd10305f42bbec07ea9b40"><td class="memItemLeft" align="right" valign="top"><a id="a7d2eb23a4dbd10305f42bbec07ea9b40"></a>
<a class="el" href="namespacead_1_1map_1_1restriction.html#a2e3c5cd0313717504de387a0e0ea272b">restriction::SpeedLimitList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a7d2eb23a4dbd10305f42bbec07ea9b40">getSpeedLimits</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;fullRoute)</td></tr>
<tr class="memdesc:a7d2eb23a4dbd10305f42bbec07ea9b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the speed limits of a complete route <br /></td></tr>
<tr class="separator:a7d2eb23a4dbd10305f42bbec07ea9b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d72ae12030ab0a7c47e6ab290ad9c02"><td class="memItemLeft" align="right" valign="top"><a id="a6d72ae12030ab0a7c47e6ab290ad9c02"></a>
<a class="el" href="namespacead_1_1map_1_1restriction.html#a2e3c5cd0313717504de387a0e0ea272b">restriction::SpeedLimitList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a6d72ae12030ab0a7c47e6ab290ad9c02">getSpeedLimits</a> (<a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">ConnectingRoute</a> const &amp;connectingRoute)</td></tr>
<tr class="memdesc:a6d72ae12030ab0a7c47e6ab290ad9c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the speed limits of a connecting route <br /></td></tr>
<tr class="separator:a6d72ae12030ab0a7c47e6ab290ad9c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2148b7cb8100821e50b07143ba2a55f"><td class="memItemLeft" align="right" valign="top"><a id="ad2148b7cb8100821e50b07143ba2a55f"></a>
lane::LaneIdSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ad2148b7cb8100821e50b07143ba2a55f">getLanesOfRoute</a> (::<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">ad::map::route::FullRoute</a> const &amp;route)</td></tr>
<tr class="memdesc:ad2148b7cb8100821e50b07143ba2a55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a set of lanes of a route <br /></td></tr>
<tr class="separator:ad2148b7cb8100821e50b07143ba2a55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c051c129fff58bab0518e682eb7a9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a62c051c129fff58bab0518e682eb7a9f">isWithinInterval</a> (<a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;roadSegment, <a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;point)</td></tr>
<tr class="memdesc:a62c051c129fff58bab0518e682eb7a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the point is within the roadSegment  <a href="namespacead_1_1map_1_1route.html#a62c051c129fff58bab0518e682eb7a9f">More...</a><br /></td></tr>
<tr class="separator:a62c051c129fff58bab0518e682eb7a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af077106cf0c693172139327590b7f539"><td class="memItemLeft" align="right" valign="top">physics::Distance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#af077106cf0c693172139327590b7f539">calcLength</a> (<a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a> const &amp;findWaypointResult)</td></tr>
<tr class="memdesc:af077106cf0c693172139327590b7f539"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the length of the route in respect to <a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html" title="struct defining the result type of findWaypoint() and findNearestWaypoint()">FindWaypointResult</a>  <a href="namespacead_1_1map_1_1route.html#af077106cf0c693172139327590b7f539">More...</a><br /></td></tr>
<tr class="separator:af077106cf0c693172139327590b7f539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296035ce0df0e63ee3dc2e3bb6bd7988"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a296035ce0df0e63ee3dc2e3bb6bd7988">findWaypoint</a> (<a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;position, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route)</td></tr>
<tr class="memdesc:a296035ce0df0e63ee3dc2e3bb6bd7988"><td class="mdescLeft">&#160;</td><td class="mdescRight">find a waypoint on the route containing the given position  <a href="namespacead_1_1map_1_1route.html#a296035ce0df0e63ee3dc2e3bb6bd7988">More...</a><br /></td></tr>
<tr class="separator:a296035ce0df0e63ee3dc2e3bb6bd7988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8ae0d2cf3a35534beaa935db292c29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a6d8ae0d2cf3a35534beaa935db292c29">findWaypoint</a> (<a class="el" href="classad_1_1map_1_1lane_1_1LaneId.html">lane::LaneId</a> const &amp;lane_id, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route)</td></tr>
<tr class="memdesc:a6d8ae0d2cf3a35534beaa935db292c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">find a waypoint on the route containing the given lane_id  <a href="namespacead_1_1map_1_1route.html#a6d8ae0d2cf3a35534beaa935db292c29">More...</a><br /></td></tr>
<tr class="separator:a6d8ae0d2cf3a35534beaa935db292c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48bfd187f7de4af11569c8694bcdab8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ad48bfd187f7de4af11569c8694bcdab8">findWaypoint</a> (physics::Distance const &amp;distance, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route)</td></tr>
<tr class="memdesc:ad48bfd187f7de4af11569c8694bcdab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">find a waypoint on the route at a given distance from the start  <a href="namespacead_1_1map_1_1route.html#ad48bfd187f7de4af11569c8694bcdab8">More...</a><br /></td></tr>
<tr class="separator:ad48bfd187f7de4af11569c8694bcdab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758674cc378d7ce72fb69e10030ffba2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a758674cc378d7ce72fb69e10030ffba2">findNearestWaypoint</a> (<a class="el" href="namespacead_1_1map_1_1point.html#a61ca5a48026fe858c1f9db0167256fda">point::ParaPointList</a> const &amp;positions, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route)</td></tr>
<tr class="memdesc:a758674cc378d7ce72fb69e10030ffba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">find waypoint on the route containing the given positions  <a href="namespacead_1_1map_1_1route.html#a758674cc378d7ce72fb69e10030ffba2">More...</a><br /></td></tr>
<tr class="separator:a758674cc378d7ce72fb69e10030ffba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44513ee2ab506a815e3ca5648802715b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a44513ee2ab506a815e3ca5648802715b">findCenterWaypoint</a> (<a class="el" href="structad_1_1map_1_1match_1_1Object.html">match::Object</a> const &amp;object, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route)</td></tr>
<tr class="memdesc:a44513ee2ab506a815e3ca5648802715b"><td class="mdescLeft">&#160;</td><td class="mdescRight">find waypoint on the route of the given object, preferable the object center  <a href="namespacead_1_1map_1_1route.html#a44513ee2ab506a815e3ca5648802715b">More...</a><br /></td></tr>
<tr class="separator:a44513ee2ab506a815e3ca5648802715b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff590f45f2617c0e840cdabb96b97cf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#aff590f45f2617c0e840cdabb96b97cf1">objectOnRoute</a> (<a class="el" href="structad_1_1map_1_1match_1_1MapMatchedObjectBoundingBox.html">match::MapMatchedObjectBoundingBox</a> const &amp;object, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route)</td></tr>
<tr class="memdesc:aff590f45f2617c0e840cdabb96b97cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">find nearest waypoint on the route containing the given mapmatched bounding box  <a href="namespacead_1_1map_1_1route.html#aff590f45f2617c0e840cdabb96b97cf1">More...</a><br /></td></tr>
<tr class="separator:aff590f45f2617c0e840cdabb96b97cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a42981a92717fcc1d81e610256473f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#aa4a42981a92717fcc1d81e610256473f">intersectionOnRoute</a> (<a class="el" href="classad_1_1map_1_1intersection_1_1Intersection.html">intersection::Intersection</a> const &amp;intersection, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route)</td></tr>
<tr class="memdesc:aa4a42981a92717fcc1d81e610256473f"><td class="mdescLeft">&#160;</td><td class="mdescRight">find waypoint on the route containing a lane of the given intersection  <a href="namespacead_1_1map_1_1route.html#aa4a42981a92717fcc1d81e610256473f">More...</a><br /></td></tr>
<tr class="separator:aa4a42981a92717fcc1d81e610256473f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba66fce67fc89973d04dd2911207f79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a6ba66fce67fc89973d04dd2911207f79">isConnectedRoutePartOfAnIntersection</a> (<a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">route::ConnectingRoute</a> const &amp;connectingRoute)</td></tr>
<tr class="separator:a6ba66fce67fc89973d04dd2911207f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c0d488cac940da9ca40d2c7b924ccc"><td class="memItemLeft" align="right" valign="top">physics::Probability&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a67c0d488cac940da9ca40d2c7b924ccc">getHeadingFeasibility</a> (<a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">route::ConnectingRoute</a> const &amp;connectingRoute)</td></tr>
<tr class="separator:a67c0d488cac940da9ca40d2c7b924ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6da2fdd5dde0e95432c7361d5011d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">route::ConnectingRoute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a3a6da2fdd5dde0e95432c7361d5011d4">swapConnectingRouteObjects</a> (<a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">route::ConnectingRoute</a> const &amp;connectingRoute)</td></tr>
<tr class="memdesc:a3a6da2fdd5dde0e95432c7361d5011d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a connecting route with swapped objects  <a href="namespacead_1_1map_1_1route.html#a3a6da2fdd5dde0e95432c7361d5011d4">More...</a><br /></td></tr>
<tr class="separator:a3a6da2fdd5dde0e95432c7361d5011d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d11559f11b6e58e1fc13ac89a9a9ec3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822">ShortenRouteResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a2d11559f11b6e58e1fc13ac89a9a9ec3">shortenRoute</a> (<a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;currentPosition, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;route, <a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670">ShortenRouteMode</a> const shortenRouteMode=<a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670a960b44c579bc2f6818d2daaf9e4c16f0">ShortenRouteMode::Normal</a>)</td></tr>
<tr class="memdesc:a2d11559f11b6e58e1fc13ac89a9a9ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">follow the route up to a certain position and shorten the route accordingly  <a href="namespacead_1_1map_1_1route.html#a2d11559f11b6e58e1fc13ac89a9a9ec3">More...</a><br /></td></tr>
<tr class="separator:a2d11559f11b6e58e1fc13ac89a9a9ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c574bba440d395d9d9036a39a949f98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822">ShortenRouteResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a7c574bba440d395d9d9036a39a949f98">shortenRoute</a> (<a class="el" href="namespacead_1_1map_1_1point.html#a61ca5a48026fe858c1f9db0167256fda">point::ParaPointList</a> const &amp;currentPositions, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;route, <a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670">ShortenRouteMode</a> const shortenRouteMode=<a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670a960b44c579bc2f6818d2daaf9e4c16f0">ShortenRouteMode::Normal</a>)</td></tr>
<tr class="memdesc:a7c574bba440d395d9d9036a39a949f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">follow the route up to a certain position and shorten the route accordingly  <a href="namespacead_1_1map_1_1route.html#a7c574bba440d395d9d9036a39a949f98">More...</a><br /></td></tr>
<tr class="separator:a7c574bba440d395d9d9036a39a949f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff99d71ff5a033ebae01bea53b88f91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822">ShortenRouteResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#afff99d71ff5a033ebae01bea53b88f91">shortenRoute</a> (<a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a> const &amp;findWaypointResult, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;route, <a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670">ShortenRouteMode</a> const shortenRouteMode=<a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670a960b44c579bc2f6818d2daaf9e4c16f0">ShortenRouteMode::Normal</a>)</td></tr>
<tr class="memdesc:afff99d71ff5a033ebae01bea53b88f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">follow the route until the provided <a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html" title="struct defining the result type of findWaypoint() and findNearestWaypoint()">FindWaypointResult</a>  <a href="namespacead_1_1map_1_1route.html#afff99d71ff5a033ebae01bea53b88f91">More...</a><br /></td></tr>
<tr class="separator:afff99d71ff5a033ebae01bea53b88f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610a706b502987b014c27d969e67f63a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822">ShortenRouteResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a610a706b502987b014c27d969e67f63a">shortenRoute</a> (const physics::Distance &amp;length_to_shorten, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;route, <a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670">ShortenRouteMode</a> const shortenRouteMode=<a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670a960b44c579bc2f6818d2daaf9e4c16f0">ShortenRouteMode::Normal</a>)</td></tr>
<tr class="memdesc:a610a706b502987b014c27d969e67f63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">follow the route by the given length  <a href="namespacead_1_1map_1_1route.html#a610a706b502987b014c27d969e67f63a">More...</a><br /></td></tr>
<tr class="separator:a610a706b502987b014c27d969e67f63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d2779b19827861271c7f7523e8c836"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a38d2779b19827861271c7f7523e8c836">calculateRouteParaPointAtDistance</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route, <a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html">route::RouteParaPoint</a> const &amp;origin, physics::Distance const &amp;distance, <a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html">route::RouteParaPoint</a> &amp;resultingPoint)</td></tr>
<tr class="memdesc:a38d2779b19827861271c7f7523e8c836"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the <a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html" title="DataType RouteParaPoint.">RouteParaPoint</a> at a given distance to a given <a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html" title="DataType RouteParaPoint.">RouteParaPoint</a>  <a href="namespacead_1_1map_1_1route.html#a38d2779b19827861271c7f7523e8c836">More...</a><br /></td></tr>
<tr class="separator:a38d2779b19827861271c7f7523e8c836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399f2ab08717a22f52cc1bc3c52cc1ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a399f2ab08717a22f52cc1bc3c52cc1ec">getRouteParaPointFromParaPoint</a> (<a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;para_point, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;route, <a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html">route::RouteParaPoint</a> &amp;routeParaPoint)</td></tr>
<tr class="memdesc:a399f2ab08717a22f52cc1bc3c52cc1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the <a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html" title="DataType RouteParaPoint.">RouteParaPoint</a> for a given ParaPoint and <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html" title="DataType FullRoute.">FullRoute</a>  <a href="namespacead_1_1map_1_1route.html#a399f2ab08717a22f52cc1bc3c52cc1ec">More...</a><br /></td></tr>
<tr class="separator:a399f2ab08717a22f52cc1bc3c52cc1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93e130d9c2e40045e9c5dd8ca68987e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#aa93e130d9c2e40045e9c5dd8ca68987e">getRouteSection</a> (<a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a> const &amp;currentLane, physics::Distance const &amp;distanceFront, physics::Distance const &amp;distanceEnd, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;route, <a class="el" href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14ec">RouteSectionCreationMode</a> const routeSectionCreationMode=<a class="el" href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14eca74984df073bdd6adc2d642e66956e1c3">RouteSectionCreationMode::SingleLane</a>)</td></tr>
<tr class="memdesc:aa93e130d9c2e40045e9c5dd8ca68987e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a section of the route that is within the given distance around the given LanePoint.  <a href="namespacead_1_1map_1_1route.html#aa93e130d9c2e40045e9c5dd8ca68987e">More...</a><br /></td></tr>
<tr class="separator:aa93e130d9c2e40045e9c5dd8ca68987e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34486bfa4efa7849e74b8f51f74204e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a34486bfa4efa7849e74b8f51f74204e6">getRouteSection</a> (<a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;center_point, physics::Distance const &amp;distanceFront, physics::Distance const &amp;distanceEnd, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route, <a class="el" href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14ec">RouteSectionCreationMode</a> const routeSectionCreationMode=<a class="el" href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14eca74984df073bdd6adc2d642e66956e1c3">RouteSectionCreationMode::SingleLane</a>)</td></tr>
<tr class="memdesc:a34486bfa4efa7849e74b8f51f74204e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a section of the route that is within the given distance around the given LanePoint.  <a href="namespacead_1_1map_1_1route.html#a34486bfa4efa7849e74b8f51f74204e6">More...</a><br /></td></tr>
<tr class="separator:a34486bfa4efa7849e74b8f51f74204e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ae53b920b4483461da84a00768f643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ac5ae53b920b4483461da84a00768f643">getRouteSection</a> (<a class="el" href="structad_1_1map_1_1match_1_1Object.html">match::Object</a> const &amp;object, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route, <a class="el" href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14ec">RouteSectionCreationMode</a> const routeSectionCreationMode=<a class="el" href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14eca74984df073bdd6adc2d642e66956e1c3">RouteSectionCreationMode::SingleLane</a>)</td></tr>
<tr class="memdesc:ac5ae53b920b4483461da84a00768f643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a section of the route that is around the given object.  <a href="namespacead_1_1map_1_1route.html#ac5ae53b920b4483461da84a00768f643">More...</a><br /></td></tr>
<tr class="separator:ac5ae53b920b4483461da84a00768f643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae650ab47205b04d82d1be2174c2e627b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1FindLaneChangeResult.html">FindLaneChangeResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ae650ab47205b04d82d1be2174c2e627b">findFirstLaneChange</a> (<a class="el" href="structad_1_1map_1_1match_1_1MapMatchedPosition.html">match::MapMatchedPosition</a> const &amp;currentPositionEgoVehicle, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route)</td></tr>
<tr class="memdesc:ae650ab47205b04d82d1be2174c2e627b"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the first route interval on a given route where a lane change is necessary to travel the given route from start to end. The function finds the first lane change only.  <a href="namespacead_1_1map_1_1route.html#ae650ab47205b04d82d1be2174c2e627b">More...</a><br /></td></tr>
<tr class="separator:ae650ab47205b04d82d1be2174c2e627b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eabef74048da7168df8941310e5dede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a4eabef74048da7168df8941310e5dede">shortenRouteToDistance</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;route, const physics::Distance &amp;length, <a class="el" href="namespacead_1_1map_1_1route.html#aaded03d451bb5ec6e0a6a6a895d081de">ShortenRouteToDistanceMode</a> const mode=<a class="el" href="namespacead_1_1map_1_1route.html#aaded03d451bb5ec6e0a6a6a895d081deaad20191b579063ba3dd57c9ae79fa74e">ShortenRouteToDistanceMode::DontCutIntersection</a>)</td></tr>
<tr class="memdesc:a4eabef74048da7168df8941310e5dede"><td class="mdescLeft">&#160;</td><td class="mdescRight">shorten the route from the end to have at maximum the given length  <a href="namespacead_1_1map_1_1route.html#a4eabef74048da7168df8941310e5dede">More...</a><br /></td></tr>
<tr class="separator:a4eabef74048da7168df8941310e5dede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20903bf15e4e779a1e10fc4f425336b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ab20903bf15e4e779a1e10fc4f425336b">appendLaneSegmentToRoute</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">route::LaneInterval</a> const &amp;lane_interval, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;route, <a class="el" href="namespacead_1_1map_1_1route.html#a71b421d8921da377162d82c18c438f88">route::SegmentCounter</a> const segment_count_from_destination=0u)</td></tr>
<tr class="memdesc:ab20903bf15e4e779a1e10fc4f425336b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to append a new lane interval to a road segment list  <a href="namespacead_1_1map_1_1route.html#ab20903bf15e4e779a1e10fc4f425336b">More...</a><br /></td></tr>
<tr class="separator:ab20903bf15e4e779a1e10fc4f425336b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ce95966f511278900f9d9838510f17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#aa9ce95966f511278900f9d9838510f17">extendRouteToDistance</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;route, physics::Distance const &amp;length, <a class="el" href="namespacead_1_1map_1_1route.html#a8cb86eafe66b8bfadd78ba5516e19ffe">route::FullRouteList</a> &amp;additionalRoutes, lane::LaneIdSet const &amp;relevantLanes=ad::map::lane::LaneIdSet())</td></tr>
<tr class="memdesc:aa9ce95966f511278900f9d9838510f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">extends route to have at least the given length  <a href="namespacead_1_1map_1_1route.html#aa9ce95966f511278900f9d9838510f17">More...</a><br /></td></tr>
<tr class="separator:aa9ce95966f511278900f9d9838510f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336e7510d56fddfbb3458f0fa9bcdaa1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a336e7510d56fddfbb3458f0fa9bcdaa1">extendRouteToDestinations</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;route, const std::vector&lt; <a class="el" href="structad_1_1map_1_1route_1_1planning_1_1RoutingParaPoint.html">route::planning::RoutingParaPoint</a> &gt; &amp;dest)</td></tr>
<tr class="memdesc:a336e7510d56fddfbb3458f0fa9bcdaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">extends route with the given list of destinations  <a href="namespacead_1_1map_1_1route.html#a336e7510d56fddfbb3458f0fa9bcdaa1">More...</a><br /></td></tr>
<tr class="separator:a336e7510d56fddfbb3458f0fa9bcdaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a3b7dd6692e34a155339564b2be288"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a67a3b7dd6692e34a155339564b2be288">extendRouteToDestinations</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;route, const <a class="el" href="namespacead_1_1map_1_1point.html#a4e850219058769b0675051d9e6e42aa2">point::GeoPointList</a> &amp;dest)</td></tr>
<tr class="memdesc:a67a3b7dd6692e34a155339564b2be288"><td class="mdescLeft">&#160;</td><td class="mdescRight">extends route with the given list of destinations  <a href="namespacead_1_1map_1_1route.html#a67a3b7dd6692e34a155339564b2be288">More...</a><br /></td></tr>
<tr class="separator:a67a3b7dd6692e34a155339564b2be288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae2ad49e85cb12962652274ba892257"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a3ae2ad49e85cb12962652274ba892257">appendRoadSegmentToRoute</a> (<a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">route::LaneInterval</a> const &amp;laneInverval, <a class="el" href="namespacead_1_1map_1_1route.html#adf33d33b9c6c78ec77b2544c09021b6e">route::RouteLaneOffset</a> const &amp;laneOffset, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;route, lane::LaneIdSet const &amp;relevantLanes)</td></tr>
<tr class="memdesc:a3ae2ad49e85cb12962652274ba892257"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to append a new lane interval to a road segment list  <a href="namespacead_1_1map_1_1route.html#a3ae2ad49e85cb12962652274ba892257">More...</a><br /></td></tr>
<tr class="separator:a3ae2ad49e85cb12962652274ba892257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d0edd7515c4426fabaeb21ca845e06"><td class="memItemLeft" align="right" valign="top">physics::Distance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a60d0edd7515c4426fabaeb21ca845e06">addOpposingLaneSegmentToRoadSegment</a> (<a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;startpoint, physics::Distance const &amp;distance, <a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">route::RoadSegment</a> &amp;roadSegment, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;route)</td></tr>
<tr class="memdesc:a60d0edd7515c4426fabaeb21ca845e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an opposing lane segment to an existing (and not empty) road segment with at most the given length  <a href="namespacead_1_1map_1_1route.html#a60d0edd7515c4426fabaeb21ca845e06">More...</a><br /></td></tr>
<tr class="separator:a60d0edd7515c4426fabaeb21ca845e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb82da8237940d6b6b66eb722077cd63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#adb82da8237940d6b6b66eb722077cd63">addOpposingLaneToRoute</a> (<a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;pointOnOppositeLane, physics::Distance const &amp;distanceOnWrongLane, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;route, physics::Distance &amp;coveredDistance)</td></tr>
<tr class="memdesc:adb82da8237940d6b6b66eb722077cd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a part of the opposing lane to an existing route. The part is at most distanceOnWrongLane long, but may be shorter (e.g. intersections stop adding more segments of the opposing lane)  <a href="namespacead_1_1map_1_1route.html#adb82da8237940d6b6b66eb722077cd63">More...</a><br /></td></tr>
<tr class="separator:adb82da8237940d6b6b66eb722077cd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2a84a5d47bc4106d00ce46dc800945"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a3a2a84a5d47bc4106d00ce46dc800945">getRouteExpandedTo</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route, <a class="el" href="namespacead_1_1map_1_1route.html#aaae9bcaf2936b1abe025aebd0fcbd77b">RouteCreationMode</a> const route_creation_mode)</td></tr>
<tr class="separator:a3a2a84a5d47bc4106d00ce46dc800945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdcd283975e580d7b97029c3444f27e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a3cdcd283975e580d7b97029c3444f27e">getRouteExpandedToSameDrivingDirectionLanesOnly</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route)</td></tr>
<tr class="separator:a3cdcd283975e580d7b97029c3444f27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0e75a67039133b0ba8aa02e9c63bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a9d0e75a67039133b0ba8aa02e9c63bf0">getRouteExpandedToOppositeLanes</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route)</td></tr>
<tr class="separator:a9d0e75a67039133b0ba8aa02e9c63bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fff411498b17437ba2432ca76856cfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a5fff411498b17437ba2432ca76856cfe">getRouteExpandedToAllNeighborLanes</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route)</td></tr>
<tr class="separator:a5fff411498b17437ba2432ca76856cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcdb605bcc920937e66fec956593439"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#affcdb605bcc920937e66fec956593439">calculateBypassingRoute</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;route, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;bypassingRoute)</td></tr>
<tr class="memdesc:affcdb605bcc920937e66fec956593439"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate a bypassing route for a given (blocked) route  <a href="namespacead_1_1map_1_1route.html#affcdb605bcc920937e66fec956593439">More...</a><br /></td></tr>
<tr class="separator:affcdb605bcc920937e66fec956593439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d3ea49458157e64f5292b1faee70bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1ECEFBorder.html">lane::ECEFBorder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a34d3ea49458157e64f5292b1faee70bd">getECEFBorderOfRoadSegment</a> (<a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;roadSegment, physics::ParametricValue const parametric_offset)</td></tr>
<tr class="memdesc:a34d3ea49458157e64f5292b1faee70bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get borders of a road segment. The road segment is cut at a given parametric offset.  <a href="namespacead_1_1map_1_1route.html#a34d3ea49458157e64f5292b1faee70bd">More...</a><br /></td></tr>
<tr class="separator:a34d3ea49458157e64f5292b1faee70bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98bf86f9c0de9d68aff4890ae2eefe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1ECEFBorder.html">lane::ECEFBorder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ac98bf86f9c0de9d68aff4890ae2eefe0">getECEFBorderOfRoadSegment</a> (<a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;roadSegment)</td></tr>
<tr class="memdesc:ac98bf86f9c0de9d68aff4890ae2eefe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">get borders of a road segment  <a href="namespacead_1_1map_1_1route.html#ac98bf86f9c0de9d68aff4890ae2eefe0">More...</a><br /></td></tr>
<tr class="separator:ac98bf86f9c0de9d68aff4890ae2eefe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec8d8257662a6b5c39192ce8237aea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1ENUBorder.html">lane::ENUBorder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a1ec8d8257662a6b5c39192ce8237aea7">getENUBorderOfRoadSegment</a> (<a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;roadSegment, physics::ParametricValue const parametric_offset)</td></tr>
<tr class="memdesc:a1ec8d8257662a6b5c39192ce8237aea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get borders of a road segment. The road segment is cut at a given parametric offset.  <a href="namespacead_1_1map_1_1route.html#a1ec8d8257662a6b5c39192ce8237aea7">More...</a><br /></td></tr>
<tr class="separator:a1ec8d8257662a6b5c39192ce8237aea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f96d43866b112fcf7646c93af22b80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1ENUBorder.html">lane::ENUBorder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a20f96d43866b112fcf7646c93af22b80">getENUBorderOfRoadSegment</a> (<a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;roadSegment)</td></tr>
<tr class="memdesc:a20f96d43866b112fcf7646c93af22b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">get borders of a road segment  <a href="namespacead_1_1map_1_1route.html#a20f96d43866b112fcf7646c93af22b80">More...</a><br /></td></tr>
<tr class="separator:a20f96d43866b112fcf7646c93af22b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8422ea51630acb7c61fbd5c461f5014e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1GeoBorder.html">lane::GeoBorder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a8422ea51630acb7c61fbd5c461f5014e">getGeoBorderOfRoadSegment</a> (<a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;roadSegment, physics::ParametricValue const parametric_offset)</td></tr>
<tr class="memdesc:a8422ea51630acb7c61fbd5c461f5014e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get borders of a road segment. The road segment is cut at a given parametric offset.  <a href="namespacead_1_1map_1_1route.html#a8422ea51630acb7c61fbd5c461f5014e">More...</a><br /></td></tr>
<tr class="separator:a8422ea51630acb7c61fbd5c461f5014e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace048225308a13f5a679a041b170ff0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structad_1_1map_1_1lane_1_1GeoBorder.html">lane::GeoBorder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#ace048225308a13f5a679a041b170ff0f">getGeoBorderOfRoadSegment</a> (<a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;roadSegment)</td></tr>
<tr class="memdesc:ace048225308a13f5a679a041b170ff0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get borders of a road segment  <a href="namespacead_1_1map_1_1route.html#ace048225308a13f5a679a041b170ff0f">More...</a><br /></td></tr>
<tr class="separator:ace048225308a13f5a679a041b170ff0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2488ff0e8400f9e4f4588b0878ef63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacead_1_1map_1_1lane.html#a00ad8891bdb4c04eaebad6511ee47829">lane::ENUBorderList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a3f2488ff0e8400f9e4f4588b0878ef63">getENUBorderOfRoute</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;route)</td></tr>
<tr class="memdesc:a3f2488ff0e8400f9e4f4588b0878ef63"><td class="mdescLeft">&#160;</td><td class="mdescRight">get borders of a full route  <a href="namespacead_1_1map_1_1route.html#a3f2488ff0e8400f9e4f4588b0878ef63">More...</a><br /></td></tr>
<tr class="separator:a3f2488ff0e8400f9e4f4588b0878ef63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f14ee5e3c8b668eddd7c7925b748c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacead_1_1map_1_1lane.html#affbbb4ff457044f17bf7ed620a013a0a">lane::ECEFBorderList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#af8f14ee5e3c8b668eddd7c7925b748c0">getECEFBorderOfRoute</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;route)</td></tr>
<tr class="memdesc:af8f14ee5e3c8b668eddd7c7925b748c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">get borders of a full route  <a href="namespacead_1_1map_1_1route.html#af8f14ee5e3c8b668eddd7c7925b748c0">More...</a><br /></td></tr>
<tr class="separator:af8f14ee5e3c8b668eddd7c7925b748c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0346a464faafb784bf2988fa90d3dd68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacead_1_1map_1_1lane.html#a581a2cb5308cc92a81657645c5a9e621">lane::GeoBorderList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a0346a464faafb784bf2988fa90d3dd68">getGeoBorderOfRoute</a> (<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;route)</td></tr>
<tr class="memdesc:a0346a464faafb784bf2988fa90d3dd68"><td class="mdescLeft">&#160;</td><td class="mdescRight">get borders of a full route  <a href="namespacead_1_1map_1_1route.html#a0346a464faafb784bf2988fa90d3dd68">More...</a><br /></td></tr>
<tr class="separator:a0346a464faafb784bf2988fa90d3dd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed34621501e49d81fa4dc0383d9bd5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classad_1_1map_1_1point_1_1ENUHeading.html">point::ENUHeading</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#abed34621501e49d81fa4dc0383d9bd5b">getENUHeadingOfRoute</a> (<a class="el" href="structad_1_1map_1_1match_1_1Object.html">match::Object</a> const &amp;object, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;route)</td></tr>
<tr class="memdesc:abed34621501e49d81fa4dc0383d9bd5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the ENU heading of a route at the location of the object  <a href="namespacead_1_1map_1_1route.html#abed34621501e49d81fa4dc0383d9bd5b">More...</a><br /></td></tr>
<tr class="separator:abed34621501e49d81fa4dc0383d9bd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd4f807c719eae6e94596407d608c8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a5dd4f807c719eae6e94596407d608c8c">isObjectHeadingInRouteDirection</a> (<a class="el" href="structad_1_1map_1_1match_1_1Object.html">match::Object</a> const &amp;object, <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;route)</td></tr>
<tr class="memdesc:a5dd4f807c719eae6e94596407d608c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare the ENU heading of the route at the location of the object with the ENU heading of the object  <a href="namespacead_1_1map_1_1route.html#a5dd4f807c719eae6e94596407d608c8c">More...</a><br /></td></tr>
<tr class="separator:a5dd4f807c719eae6e94596407d608c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe49da893591a3c153a4eae8ae9b3474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#abe49da893591a3c153a4eae8ae9b3474">shortenSegmentFromBegin</a> (<a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> &amp;roadSegment, physics::Distance const &amp;distance)</td></tr>
<tr class="memdesc:abe49da893591a3c153a4eae8ae9b3474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorten the provided road segment by a certain distance from the begin.  <a href="namespacead_1_1map_1_1route.html#abe49da893591a3c153a4eae8ae9b3474">More...</a><br /></td></tr>
<tr class="separator:abe49da893591a3c153a4eae8ae9b3474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d4acb6f7555cd1008e596c25395e21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacead_1_1map_1_1route.html#a01d4acb6f7555cd1008e596c25395e21">shortenSegmentFromEnd</a> (<a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> &amp;roadSegment, physics::Distance const &amp;distance)</td></tr>
<tr class="memdesc:a01d4acb6f7555cd1008e596c25395e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorten the provided road segment by a certain distance from the end.  <a href="namespacead_1_1map_1_1route.html#a01d4acb6f7555cd1008e596c25395e21">More...</a><br /></td></tr>
<tr class="separator:a01d4acb6f7555cd1008e596c25395e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace route </p>
<p>Handling of routes </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a7ad5dcc51516f086ed5a98b31914be53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad5dcc51516f086ed5a98b31914be53">&#9670;&nbsp;</a></span>ConnectingRouteList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;::<a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">ad::map::route::ConnectingRoute</a>&gt; <a class="el" href="namespacead_1_1map_1_1route.html#a7ad5dcc51516f086ed5a98b31914be53">ad::map::route::ConnectingRouteList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DataType ConnectingRouteList. </p>
<p>List of <a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html" title="DataType ConnectingRoute.">ConnectingRoute</a> elements </p>

</div>
</div>
<a id="a8cb86eafe66b8bfadd78ba5516e19ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb86eafe66b8bfadd78ba5516e19ffe">&#9670;&nbsp;</a></span>FullRouteList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;::<a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">ad::map::route::FullRoute</a>&gt; <a class="el" href="namespacead_1_1map_1_1route.html#a8cb86eafe66b8bfadd78ba5516e19ffe">ad::map::route::FullRouteList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DataType FullRouteList. </p>
<p>List of <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html" title="DataType FullRoute.">FullRoute</a> elements </p>

</div>
</div>
<a id="af238c949adaf82d03c9edac92b60e054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af238c949adaf82d03c9edac92b60e054">&#9670;&nbsp;</a></span>LaneSegmentList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;::<a class="el" href="structad_1_1map_1_1route_1_1LaneSegment.html">ad::map::route::LaneSegment</a>&gt; <a class="el" href="namespacead_1_1map_1_1route.html#af238c949adaf82d03c9edac92b60e054">ad::map::route::LaneSegmentList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DataType LaneSegmentList. </p>
<p>A list of lane segments </p>

</div>
</div>
<a id="a83a23df4255ebcbd2b7be9b89d99f095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a23df4255ebcbd2b7be9b89d99f095">&#9670;&nbsp;</a></span>RoadSegmentList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;::<a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">ad::map::route::RoadSegment</a>&gt; <a class="el" href="namespacead_1_1map_1_1route.html#a83a23df4255ebcbd2b7be9b89d99f095">ad::map::route::RoadSegmentList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DataType RoadSegmentList. </p>
<p>A list of road segments </p>

</div>
</div>
<a id="adf33d33b9c6c78ec77b2544c09021b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf33d33b9c6c78ec77b2544c09021b6e">&#9670;&nbsp;</a></span>RouteLaneOffset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t <a class="el" href="namespacead_1_1map_1_1route.html#adf33d33b9c6c78ec77b2544c09021b6e">ad::map::route::RouteLaneOffset</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DataType RouteLaneOffset. </p>
<p>The offset of a lane in number of lane changes left (&ndash;) or right (++) from start of the route planning. </p>

</div>
</div>
<a id="a71b421d8921da377162d82c18c438f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b421d8921da377162d82c18c438f88">&#9670;&nbsp;</a></span>SegmentCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="namespacead_1_1map_1_1route.html#a71b421d8921da377162d82c18c438f88">ad::map::route::SegmentCounter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DataType SegmentCounter. </p>
<p>A counter for segments </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a19ef80d84e69ba2770b30d81e9029aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ef80d84e69ba2770b30d81e9029aa8">&#9670;&nbsp;</a></span>ConnectingRouteType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacead_1_1map_1_1route.html#a19ef80d84e69ba2770b30d81e9029aa8">ad::map::route::ConnectingRouteType</a> : int32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DataType ConnectingRouteType. </p>
<p>The type of a connecting route. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a19ef80d84e69ba2770b30d81e9029aa8a4bbb8f967da6d1a610596d7257179c2b"></a>Invalid&#160;</td><td class="fielddoc"><p>There exists no connecting route (according to the search length/distance restrictions): both route_a and route_b are empty </p>
</td></tr>
<tr><td class="fieldname"><a id="a19ef80d84e69ba2770b30d81e9029aa8a6f796b0e6deb4f4c2c0ee0ed5e10e117"></a>Following&#160;</td><td class="fielddoc"><p>A and B are driving in same direction: one is able to reach the other by driving forward, but not vice versa If A is in front of B: route_a is empty, route_b contains the route part from B towards A If B is in front of A: route_b is empty, route_a contains the route part from A towards B </p>
</td></tr>
<tr><td class="fieldname"><a id="a19ef80d84e69ba2770b30d81e9029aa8a0ef9a6968cfe92f7bde817483fb5d0cf"></a>Opposing&#160;</td><td class="fielddoc"><p>A and B driving in opposite direction: both are able to reach each other by driving forward: route_a contains the route part from A towards B and route_b the inverted route part from B towards A. </p>
</td></tr>
<tr><td class="fieldname"><a id="a19ef80d84e69ba2770b30d81e9029aa8a76eaf4e29d18aa0bc8f10f646fc789bf"></a>Merging&#160;</td><td class="fielddoc"><p>A and B can reach each other directly, but their routes merge at some point: route_a contains the route part from A towards the merge point route_b contains the route part from B towards the merge point </p>
</td></tr>
</table>

</div>
</div>
<a id="ab046615abf5d3c8c412d213a61670383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab046615abf5d3c8c412d213a61670383">&#9670;&nbsp;</a></span>LaneChangeDirection</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacead_1_1map_1_1route.html#ab046615abf5d3c8c412d213a61670383">ad::map::route::LaneChangeDirection</a> : int32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DataType LaneChangeDirection. </p>
<p>Direction of a lane change </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab046615abf5d3c8c412d213a61670383ad1e80c506f4c89e3c4fb1c1b4867a03c"></a>LeftToRight&#160;</td><td class="fielddoc"><p>Change a lane from left to right </p>
</td></tr>
<tr><td class="fieldname"><a id="ab046615abf5d3c8c412d213a61670383ab7b0ea3028791689ea070674776855e2"></a>RightToLeft&#160;</td><td class="fielddoc"><p>Change a lane from right to left </p>
</td></tr>
<tr><td class="fieldname"><a id="ab046615abf5d3c8c412d213a61670383a4bbb8f967da6d1a610596d7257179c2b"></a>Invalid&#160;</td><td class="fielddoc"><p>Invalid lane change direction </p>
</td></tr>
</table>

</div>
</div>
<a id="aaae9bcaf2936b1abe025aebd0fcbd77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae9bcaf2936b1abe025aebd0fcbd77b">&#9670;&nbsp;</a></span>RouteCreationMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacead_1_1map_1_1route.html#aaae9bcaf2936b1abe025aebd0fcbd77b">ad::map::route::RouteCreationMode</a> : int32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DataType RouteCreationMode. </p>
<p>The mode on how the full route is created </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aaae9bcaf2936b1abe025aebd0fcbd77baec0fc0100c4fc1ce4eea230c3dc10360"></a>Undefined&#160;</td><td class="fielddoc"><p>undefined value </p>
</td></tr>
<tr><td class="fieldname"><a id="aaae9bcaf2936b1abe025aebd0fcbd77bab51cd2c8724851ff796ff8cbb1cfa645"></a>SameDrivingDirection&#160;</td><td class="fielddoc"><p>Only add lanes having the same driving direction to the route </p>
</td></tr>
<tr><td class="fieldname"><a id="aaae9bcaf2936b1abe025aebd0fcbd77ba3078ff695395cfdd7f026a80ab57f514"></a>AllRoutableLanes&#160;</td><td class="fielddoc"><p>include also lanes in opposite driving direction </p>
</td></tr>
<tr><td class="fieldname"><a id="aaae9bcaf2936b1abe025aebd0fcbd77ba8dce77e8132357431d06ebfbea96adb4"></a>AllNeighborLanes&#160;</td><td class="fielddoc"><p>include all neighbors, which might include not explicitly routeable shoulder lanes </p>
</td></tr>
</table>

</div>
</div>
<a id="a5993e33e6ed864f1e1ad2a9eecbd14ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5993e33e6ed864f1e1ad2a9eecbd14ec">&#9670;&nbsp;</a></span>RouteSectionCreationMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14ec">ad::map::route::RouteSectionCreationMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the mode how the route section will be created </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5993e33e6ed864f1e1ad2a9eecbd14eca74984df073bdd6adc2d642e66956e1c3"></a>SingleLane&#160;</td><td class="fielddoc"><p>In the resulting route section the LaneSegments contain on single lane interval </p>
</td></tr>
<tr><td class="fieldname"><a id="a5993e33e6ed864f1e1ad2a9eecbd14ecaef7d65c4d0ea0862c381bafe0bf7b040"></a>AllRouteLanes&#160;</td><td class="fielddoc"><p>In the resulting route section the LaneSegments contain all the lanes of the original route </p>
</td></tr>
</table>

</div>
</div>
<a id="a35ee85c81b9b35fd5a360e296480c670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ee85c81b9b35fd5a360e296480c670">&#9670;&nbsp;</a></span>ShortenRouteMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670">ad::map::route::ShortenRouteMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>enumeration defining the mode of operation of the <a class="el" href="namespacead_1_1map_1_1route.html#a2d11559f11b6e58e1fc13ac89a9a9ec3" title="follow the route up to a certain position and shorten the route accordingly">shortenRoute()</a> functions </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a35ee85c81b9b35fd5a360e296480c670a960b44c579bc2f6818d2daaf9e4c16f0"></a>Normal&#160;</td><td class="fielddoc"><p>Standard behavior </p>
</td></tr>
<tr><td class="fieldname"><a id="a35ee85c81b9b35fd5a360e296480c670a5ec0697f06b6e0824b25d2aa2ddf811c"></a>PrependIfSucceededBeforeRoute&#160;</td><td class="fielddoc"><p>If shorten route result would be: <a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a01553498d1f57420cbecd23a7405ee8c">ShortenRouteResult::SucceededBeforeRoute</a>, the route is extended at the beginning so that the result actually becomes <a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a66d02c2f8a582446f8dd8752366002b5">ShortenRouteResult::Succeeded</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a35ee85c81b9b35fd5a360e296480c670acf85c0bbaa5860b429a47f3bc68d2991"></a>DontCutIntersectionAndPrependIfSucceededBeforeRoute&#160;</td><td class="fielddoc"><p>If the shorten route operation would cut an intersection in between, the route is not shortened further, before the intersection is actually left.</p>
<p>If shorten route result would be: <a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a01553498d1f57420cbecd23a7405ee8c">ShortenRouteResult::SucceededBeforeRoute</a>, the route is extended at the beginning so that the result actually becomes <a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a66d02c2f8a582446f8dd8752366002b5">ShortenRouteResult::Succeeded</a> </p>
</td></tr>
</table>

</div>
</div>
<a id="a7061e80e6b9053968633f62a437e2822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7061e80e6b9053968633f62a437e2822">&#9670;&nbsp;</a></span>ShortenRouteResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822">ad::map::route::ShortenRouteResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>enumeration providing more insights into the actual shorten route result </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7061e80e6b9053968633f62a437e2822a66d02c2f8a582446f8dd8752366002b5"></a>Succeeded&#160;</td><td class="fielddoc"><p>Shortening succeeded </p>
</td></tr>
<tr><td class="fieldname"><a id="a7061e80e6b9053968633f62a437e2822a01553498d1f57420cbecd23a7405ee8c"></a>SucceededBeforeRoute&#160;</td><td class="fielddoc"><p>Shortening succeeded: the actual provided position(s) were not found with the <a class="el" href="namespacead_1_1map_1_1route.html#a758674cc378d7ce72fb69e10030ffba2" title="find waypoint on the route containing the given positions">findNearestWaypoint()</a> function, but at least one position is on a lane of the route start lane segments, just before the route interval starts </p>
</td></tr>
<tr><td class="fieldname"><a id="a7061e80e6b9053968633f62a437e2822a4b0c532564b19e471cdc04ca7ba03c4c"></a>SucceededRouteEmpty&#160;</td><td class="fielddoc"><p>Shortening succeeded, but the resulting route is empty (i.e. crossed the end of the route) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7061e80e6b9053968633f62a437e2822a0d9e48e4b3e799b4d6467ad3d48912cd"></a>SucceededIntersectionNotCut&#160;</td><td class="fielddoc"><p>Shortening succeeded: the shortening would cut the current intersection within route. Therefore, actually not cut. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7061e80e6b9053968633f62a437e2822a02740addb165a62ace58585fe7c8644d"></a>FailedRouteEmpty&#160;</td><td class="fielddoc"><p>Shortening failed, the resulting (or already the input) route is empty </p>
</td></tr>
</table>

</div>
</div>
<a id="aaded03d451bb5ec6e0a6a6a895d081de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaded03d451bb5ec6e0a6a6a895d081de">&#9670;&nbsp;</a></span>ShortenRouteToDistanceMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacead_1_1map_1_1route.html#aaded03d451bb5ec6e0a6a6a895d081de">ad::map::route::ShortenRouteToDistanceMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>enumeration defining the mode of operation of the <a class="el" href="namespacead_1_1map_1_1route.html#a4eabef74048da7168df8941310e5dede" title="shorten the route from the end to have at maximum the given length">shortenRouteToDistance()</a> function </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aaded03d451bb5ec6e0a6a6a895d081deaad20191b579063ba3dd57c9ae79fa74e"></a>DontCutIntersection&#160;</td><td class="fielddoc"><p>If the shorten route operation would cut an intersection in between, the route is not shortened further, before the intersection is actually left. </p>
</td></tr>
<tr><td class="fieldname"><a id="aaded03d451bb5ec6e0a6a6a895d081dea35cbd4d90ba828274d77f67eb0462c4d"></a>AllowCutIntersection&#160;</td><td class="fielddoc"><p>The route operation also cuts an intersection in between if required. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a60d0edd7515c4426fabaeb21ca845e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d0edd7515c4426fabaeb21ca845e06">&#9670;&nbsp;</a></span>addOpposingLaneSegmentToRoadSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">physics::Distance ad::map::route::addOpposingLaneSegmentToRoadSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>startpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::Distance const &amp;&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">route::RoadSegment</a> &amp;&#160;</td>
          <td class="paramname"><em>roadSegment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;&#160;</td>
          <td class="paramname"><em>route</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add an opposing lane segment to an existing (and not empty) road segment with at most the given length </p>
<p>This function must only be used, if an existing route should be extended with an opposing lane. Note, the length of the lane segment can be less than the provided distance, in case the neighboring lane segment is shorter as well.</p>
<p>The function is used by addOpposingLaneToRoute</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startPoint</td><td>is the start point where the opposing lane segment will start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>is the maximum distance of the newly added lane segment </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>roadSegment is the road segment which is updated with the opposing lane segment </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>route is the route the road segment belons to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on failure, otherwise the length of the new lane segment is added </dd></dl>

</div>
</div>
<a id="adb82da8237940d6b6b66eb722077cd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb82da8237940d6b6b66eb722077cd63">&#9670;&nbsp;</a></span>addOpposingLaneToRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::addOpposingLaneToRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>pointOnOppositeLane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::Distance const &amp;&#160;</td>
          <td class="paramname"><em>distanceOnWrongLane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::Distance &amp;&#160;</td>
          <td class="paramname"><em>coveredDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a part of the opposing lane to an existing route. The part is at most distanceOnWrongLane long, but may be shorter (e.g. intersections stop adding more segments of the opposing lane) </p>
<p>Note the starting point of adding the opposing lane must be in the first segment of the route</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointOnOppositeLane</td><td>is the starting point at which the opposite lane should be added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distanceOnWrongLane</td><td>maximum distance on the opposite lane </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>route to be updated </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coveredDistance</td><td>is the actually covered distance of the opposing lane segment(s) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab20903bf15e4e779a1e10fc4f425336b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20903bf15e4e779a1e10fc4f425336b">&#9670;&nbsp;</a></span>appendLaneSegmentToRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::appendLaneSegmentToRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">route::LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1route.html#a71b421d8921da377162d82c18c438f88">route::SegmentCounter</a> const&#160;</td>
          <td class="paramname"><em>segment_count_from_destination</em> = <code>0u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to append a new lane interval to a road segment list </p>
<p>In contrast to <a class="el" href="namespacead_1_1map_1_1route.html#a3ae2ad49e85cb12962652274ba892257" title="function to append a new lane interval to a road segment list">appendRoadSegmentToRoute()</a> here only the lane interval without any neighbors is added</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lane_interval</td><td>the new lane interval to be append </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route the interval has to be appended </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">segment_count_from_destination</td><td>the segment count for the new road segment to be created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ae2ad49e85cb12962652274ba892257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae2ad49e85cb12962652274ba892257">&#9670;&nbsp;</a></span>appendRoadSegmentToRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::appendRoadSegmentToRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">route::LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>laneInverval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1route.html#adf33d33b9c6c78ec77b2544c09021b6e">route::RouteLaneOffset</a> const &amp;&#160;</td>
          <td class="paramname"><em>laneOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lane::LaneIdSet const &amp;&#160;</td>
          <td class="paramname"><em>relevantLanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to append a new lane interval to a road segment list </p>
<p>This function is mainly used while creation of a <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html" title="DataType FullRoute.">FullRoute</a> object. The lane interval is expanded by it's left and right neighbor lanes (with same driving direction) to a complete road segment; which is then appended to the provided road segment list.</p>
<p>After the route is finished, <a class="el" href="namespacead_1_1map_1_1route_1_1planning.html#a6513e09d404c33f20ac6b686a12c427a" title="update route planning counters of the route">planning::updateRoutePlanningCounters()</a> should be called to update the planning counters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lane_interval</td><td>the new lane interval to be append </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">laneOffset</td><td>the lane offset of the new lane interval to be append </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route the interval has to be appended </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relevantLanes</td><td>if not empty, the function restricts the extension to the given set of lanes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e8094fa0d77e8f63f243bbbe0197a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8094fa0d77e8f63f243bbbe0197a58">&#9670;&nbsp;</a></span>calcDuration() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">physics::Duration ad::map::route::calcDuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">ConnectingRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>connectingRoute</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the Duration of the provided connecting route </p>
<p>For Duration calculations the longest route section of this is used as reference. </p>

</div>
</div>
<a id="a7a355730845387c83f2372453dc4bd72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a355730845387c83f2372453dc4bd72">&#9670;&nbsp;</a></span>calcDuration() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">physics::Duration ad::map::route::calcDuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the Duration of the provided lane interval as duration value </p>
<p>For Duration calculations maximum allowed speed combined with the length is taken into account </p>

</div>
</div>
<a id="a0005a3e14162156e5ea973ed2c686f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0005a3e14162156e5ea973ed2c686f7f">&#9670;&nbsp;</a></span>calcDuration() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">physics::Duration ad::map::route::calcDuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;&#160;</td>
          <td class="paramname"><em>roadSegment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the Duration of the provided road segment </p>
<p>For Duration calculations the shortest road segment of this is used as reference. </p>

</div>
</div>
<a id="aeec409a8db10c3fbdc98b94f844451a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec409a8db10c3fbdc98b94f844451a2">&#9670;&nbsp;</a></span>calcLength() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">physics::Distance ad::map::route::calcLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">ConnectingRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>connectingRoute</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the length of the provided connecting route </p>
<p>For length calculations the longest route section of this is used as reference. </p>

</div>
</div>
<a id="af077106cf0c693172139327590b7f539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af077106cf0c693172139327590b7f539">&#9670;&nbsp;</a></span>calcLength() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">physics::Distance ad::map::route::calcLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a> const &amp;&#160;</td>
          <td class="paramname"><em>findWaypointResult</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the length of the route in respect to <a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html" title="struct defining the result type of findWaypoint() and findNearestWaypoint()">FindWaypointResult</a> </p>
<p>calculate the length of the route up to the queryPosition of the <a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html" title="struct defining the result type of findWaypoint() and findNearestWaypoint()">FindWaypointResult</a> </p>

</div>
</div>
<a id="a5d897db52931943339aa4df12e41f28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d897db52931943339aa4df12e41f28d">&#9670;&nbsp;</a></span>calcLength() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">physics::Distance ad::map::route::calcLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the length of the provided lane interval as physics::Distance value </p>
<p>For length calculation the parametric length of the interval (<a class="el" href="namespacead_1_1map_1_1route.html#a00c9eab4a645b934e4ce29f9c752eb86" title="calculate the length of the provided lane interval as parametric value">calcParametricLength()</a>) is multiplied by the lane's length. </p>

</div>
</div>
<a id="a117edffb03b1913a0724ebaa382f6984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117edffb03b1913a0724ebaa382f6984">&#9670;&nbsp;</a></span>calcLength() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">physics::Distance ad::map::route::calcLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;&#160;</td>
          <td class="paramname"><em>roadSegment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the length of the provided road segment </p>
<p>For length calculations the shortest road segment of this is used as reference. </p>

</div>
</div>
<a id="affcdb605bcc920937e66fec956593439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcdb605bcc920937e66fec956593439">&#9670;&nbsp;</a></span>calculateBypassingRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::calculateBypassingRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;&#160;</td>
          <td class="paramname"><em>bypassingRoute</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate a bypassing route for a given (blocked) route </p>
<p>This function is designed to by used to get a route around parking vehicles or for overtaking The output route makes use of neighboring lanes and respects left-hand/right-hand traffic flow The calculation fails when reaching an intersection</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>is the input route, which should not be used </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bypassingRoute</td><td>is the new route, making use of neighboring lanes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if no valid bypassing route was found </dd></dl>

</div>
</div>
<a id="a38d2779b19827861271c7f7523e8c836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d2779b19827861271c7f7523e8c836">&#9670;&nbsp;</a></span>calculateRouteParaPointAtDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::calculateRouteParaPointAtDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html">route::RouteParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::Distance const &amp;&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html">route::RouteParaPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>resultingPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the <a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html" title="DataType RouteParaPoint.">RouteParaPoint</a> at a given distance to a given <a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html" title="DataType RouteParaPoint.">RouteParaPoint</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>the reference point to this the distance should be calculated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>Negative value is towards begin of the route. Positive values is towards end of the route </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultingPoint</td><td>the point at distance to the origin <a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html" title="DataType RouteParaPoint.">RouteParaPoint</a></td></tr>
  </table>
  </dd>
</dl>
<p>returns <code>true</code> if the resultingParaPoint was found in the route </p>

</div>
</div>
<a id="a0d6f2e9771b978392f228b95357ba319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6f2e9771b978392f228b95357ba319">&#9670;&nbsp;</a></span>cutIntervalAtEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> ad::map::route::cutIntervalAtEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::ParametricValue const &amp;&#160;</td>
          <td class="paramname"><em>newIntervalEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cut the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> at a given parametric point. Will remove at the end of the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">the</td><td><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> that should be shortened </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newIntervalEnd</td><td>the new end of the interval if the point is within the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting shortened <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a></dd></dl>
<p>If the parametric offset is outside of the interval, the original lane interval is returned. </p>

</div>
</div>
<a id="a69cb4b5775c434a270750cc447c86033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69cb4b5775c434a270750cc447c86033">&#9670;&nbsp;</a></span>cutIntervalAtStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> ad::map::route::cutIntervalAtStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::ParametricValue const &amp;&#160;</td>
          <td class="paramname"><em>newIntervalStart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cut the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> at a given parametric point. Will remove at the start of the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">the</td><td><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> that should be shortened </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newIntervalStart</td><td>the new start of the interval if the point is within the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting shortened <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a></dd></dl>
<p>If the parametric offset is outside of the interval, the original lane interval is returned. </p>

</div>
</div>
<a id="ad63b642930ef0f7288e2cd202999811e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63b642930ef0f7288e2cd202999811e">&#9670;&nbsp;</a></span>extendIntervalFromEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> ad::map::route::extendIntervalFromEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::Distance const &amp;&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extend the lane interval by moving its end position by physics::Distance </p>
<p>If the lane interval is degenerated nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lane_interval</td><td>the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> that should be extended </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">physics::Distance</td><td>by which the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> should be extended</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting extended <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> </dd></dl>

</div>
</div>
<a id="aad8ecd32439e435ba083ddeb4f19fba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8ecd32439e435ba083ddeb4f19fba1">&#9670;&nbsp;</a></span>extendIntervalFromStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> ad::map::route::extendIntervalFromStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::Distance const &amp;&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extend the lane interval by moving its start position by physics::Distance </p>
<p>If the lane interval is degenerated nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lane_interval</td><td>the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> that should be extended </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">physics::Distance</td><td>by which the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> should be extended</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting extended <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> </dd></dl>

</div>
</div>
<a id="a0a7a71f88fa626a513f351ea5e077f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7a71f88fa626a513f351ea5e077f74">&#9670;&nbsp;</a></span>extendIntervalUntilEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> ad::map::route::extendIntervalUntilEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extend the lane interval until the end of the lane reached </p>
<p>The end is set to the lane's maximal value (depending on the route direction to 0. or 1.). If the lane interval is degenerated nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lane_interval</td><td>the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> that should be extended</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting extended <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> </dd></dl>

</div>
</div>
<a id="ac6956151942f031ba1262987033ff2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6956151942f031ba1262987033ff2b0">&#9670;&nbsp;</a></span>extendIntervalUntilStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> ad::map::route::extendIntervalUntilStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extend the lane interval until the start of the lane reached </p>
<p>The start is set to the lane's minimal value (depending on the route direction to 1. or 0.). If the lane interval is degenerated nothing is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lane_interval</td><td>the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> that should be extended</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting extended <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> </dd></dl>

</div>
</div>
<a id="a67a3b7dd6692e34a155339564b2be288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a3b7dd6692e34a155339564b2be288">&#9670;&nbsp;</a></span>extendRouteToDestinations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::extendRouteToDestinations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacead_1_1map_1_1point.html#a4e850219058769b0675051d9e6e42aa2">point::GeoPointList</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extends route with the given list of destinations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>route the route to check and to extend </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Vector with supporting points as geo points to be visited on the route. Last point in the list is the actual destination point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> is returned if the route is/was empty/degenerated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>route the route to check and to extend </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Vector with supporting points as ENU points to be visited on the route. Last point in the list is the actual destination point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> is returned if the route is/was empty/degenerated </dd></dl>

</div>
</div>
<a id="a336e7510d56fddfbb3458f0fa9bcdaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336e7510d56fddfbb3458f0fa9bcdaa1">&#9670;&nbsp;</a></span>extendRouteToDestinations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::extendRouteToDestinations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structad_1_1map_1_1route_1_1planning_1_1RoutingParaPoint.html">route::planning::RoutingParaPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extends route with the given list of destinations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>route the route to check and to extend </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Vector with supporting points as routing parametric points to be visited on the route. Last point in the list is the actual destination point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> is returned if the route is/was empty/degenerated </dd></dl>

</div>
</div>
<a id="aa9ce95966f511278900f9d9838510f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ce95966f511278900f9d9838510f17">&#9670;&nbsp;</a></span>extendRouteToDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::extendRouteToDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::Distance const &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1route.html#a8cb86eafe66b8bfadd78ba5516e19ffe">route::FullRouteList</a> &amp;&#160;</td>
          <td class="paramname"><em>additionalRoutes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lane::LaneIdSet const &amp;&#160;</td>
          <td class="paramname"><em>relevantLanes</em> = <code>ad::map::lane::LaneIdSet()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extends route to have at least the given length </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>route the route to check and to extend </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the minimum length </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>additionalRoutes additional routes in case of intersections on the extension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relevantLanes</td><td>if not empty, the function restricts the extension to the given set of lanes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of bool and vector</dd></dl>
<p><code>true</code> if the route has sufficient length or was extended. If <code>false</code> is returned the route is/was empty/degenerated or the additional routes were not empty. </p>

</div>
</div>
<a id="a44513ee2ab506a815e3ca5648802715b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44513ee2ab506a815e3ca5648802715b">&#9670;&nbsp;</a></span>findCenterWaypoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a> ad::map::route::findCenterWaypoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1match_1_1Object.html">match::Object</a> const &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find waypoint on the route of the given object, preferable the object center </p>
<p>This function first calls findNearestWayPoint on the map matched position confidence list of the center position. If this doesn't lead to a result, the center points of the respective occupied regions are used to find a waypoint. The search starts with the longest region and continues in decreasing order. If this still doesn't lead to a match findNearestWayPoint of the other map matched confidence list positions is taken.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>the object which should be searched for within the route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route to search in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>waypoint result containing an iterator pointing to the route segment the lane of the position is part of and the corresponding route interval having that lane id. </dd></dl>

</div>
</div>
<a id="ae650ab47205b04d82d1be2174c2e627b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae650ab47205b04d82d1be2174c2e627b">&#9670;&nbsp;</a></span>findFirstLaneChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1FindLaneChangeResult.html">FindLaneChangeResult</a> ad::map::route::findFirstLaneChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1match_1_1MapMatchedPosition.html">match::MapMatchedPosition</a> const &amp;&#160;</td>
          <td class="paramname"><em>currentPositionEgoVehicle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the first route interval on a given route where a lane change is necessary to travel the given route from start to end. The function finds the first lane change only. </p>
<p>The result is returned by an <a class="el" href="structad_1_1map_1_1route_1_1FindLaneChangeResult.html" title="struct defining the result type of findFirstLaneChange()">FindLaneChangeResult</a> which holds</p><ul>
<li>the routeIteratorLaneChangeStart as the pointer to the route index on where the lane change can start at the earliest. A valid routeIteratorLaneChangeStart can be in the range [std::begin(route), std::end(route)[.</li>
<li>the routeIteratorLaneChangeEnd as the point on the route where the lane change needs to be finished at the latest. A valid routeIteratorLaneChangeEnd can be in the range [std::begin(route), std::end(route)[</li>
<li>the laneChangeDirection specifying if the lane change goes from left to right or right to left.</li>
</ul>
<p>This function uses the logger of the AdMapAccess::instance() singleton.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentPositionEgoVehicle</td><td>the currentPosition of the ego vehicle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route on which the first lane change is searched</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a valid lane change result as described above if the route contains a lane change. Returns an invalid <a class="el" href="structad_1_1map_1_1route_1_1FindLaneChangeResult.html" title="struct defining the result type of findFirstLaneChange()">FindLaneChangeResult</a> if there is no lane change on the route.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the route contains invalid transitions. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the map is not initialized or the road network could not be obtained </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a758674cc378d7ce72fb69e10030ffba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758674cc378d7ce72fb69e10030ffba2">&#9670;&nbsp;</a></span>findNearestWaypoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a> ad::map::route::findNearestWaypoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1point.html#a61ca5a48026fe858c1f9db0167256fda">point::ParaPointList</a> const &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find waypoint on the route containing the given positions </p>
<p>find nearest waypoint on the route containing the given mapmatched positions</p>
<p>A version of <a class="el" href="namespacead_1_1map_1_1route.html#a296035ce0df0e63ee3dc2e3bb6bd7988" title="find a waypoint on the route containing the given position">findWaypoint()</a> allowing the position to be a vector of positions to consider and select the result near to the begin of the route. All the given positions are searched using the <a class="el" href="namespacead_1_1map_1_1route.html#a296035ce0df0e63ee3dc2e3bb6bd7988" title="find a waypoint on the route containing the given position">findWaypoint()</a>; therefore </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacead_1_1map_1_1route.html#a296035ce0df0e63ee3dc2e3bb6bd7988" title="find a waypoint on the route containing the given position">findWaypoint()</a> for further details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">positions</td><td>the position vector which should be searched for within the route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route to search in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>waypoint result containing an iterator pointing to the route segment the lane of the position is part of and the corresponding route interval having that lane id. If multiple are matching the one nearest the begin of the route is selected.</dd></dl>
<p>This function will return the nearest waypoint along the route</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapMatchedPositions</td><td>the map matched positions which should be searched for within the route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route to search in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>waypoint result containing an iterator pointing to the route segment the lane of the position is part of and the corresponding route interval having that lane id. If multiple are matching the one nearest the begin of the route is selected. </dd></dl>

</div>
</div>
<a id="a6d8ae0d2cf3a35534beaa935db292c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8ae0d2cf3a35534beaa935db292c29">&#9670;&nbsp;</a></span>findWaypoint() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a> ad::map::route::findWaypoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classad_1_1map_1_1lane_1_1LaneId.html">lane::LaneId</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find a waypoint on the route containing the given lane_id </p>
<p>The position is searched within the given full route. If the position's LaneId is present in the route, an iterator of the route is returned in conjunction with the RouteInterval defining the interval of the route covering the corresponding lane.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lane_id</td><td>the lane id which should be searched for within the route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route to search in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>waypoint result containing an iterator pointing to the route segment the lane of the position is part of and the corresponding route interval having that lane id. The query position is (on success) the start of the lane interval within the route. </dd></dl>

</div>
</div>
<a id="ad48bfd187f7de4af11569c8694bcdab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48bfd187f7de4af11569c8694bcdab8">&#9670;&nbsp;</a></span>findWaypoint() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a> ad::map::route::findWaypoint </td>
          <td>(</td>
          <td class="paramtype">physics::Distance const &amp;&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find a waypoint on the route at a given distance from the start </p>
<p>If the route is shorter that the desired distance, an iterator of the route is returned at the corresponding position within the route.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>the distance which should be progressed within the route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route to search in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>waypoint result containing an iterator pointing to the route segment at the desired distance using the corresponding first lane segment. The query position is (on success) the para point of the lane interval within the route. </dd></dl>

</div>
</div>
<a id="a296035ce0df0e63ee3dc2e3bb6bd7988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296035ce0df0e63ee3dc2e3bb6bd7988">&#9670;&nbsp;</a></span>findWaypoint() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a> ad::map::route::findWaypoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find a waypoint on the route containing the given position </p>
<p>The position is searched within the given full route. If the position's LaneId is present in the route, and the position's offset is within the route (i.e. the point lies within the route), an iterator of the route is returned in conjunction with the RouteInterval defining the interval of the route covering the corresponding lane.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>the position defining the lane id which should be searched for within the route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route to search in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>waypoint result containing an iterator pointing to the route segment the lane of the position is part of and the corresponding route interval having that lane id. The query position is the provided <em>position</em>. </dd></dl>

</div>
</div>
<a id="ac98bf86f9c0de9d68aff4890ae2eefe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98bf86f9c0de9d68aff4890ae2eefe0">&#9670;&nbsp;</a></span>getECEFBorderOfRoadSegment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1ECEFBorder.html">lane::ECEFBorder</a> ad::map::route::getECEFBorderOfRoadSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;&#160;</td>
          <td class="paramname"><em>roadSegment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get borders of a road segment </p>
<p>The order of the points within the LaneGeometries are ordered according to the route direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">roadSegment</td><td>the road segment to extract the borders from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34d3ea49458157e64f5292b1faee70bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d3ea49458157e64f5292b1faee70bd">&#9670;&nbsp;</a></span>getECEFBorderOfRoadSegment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1ECEFBorder.html">lane::ECEFBorder</a> ad::map::route::getECEFBorderOfRoadSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;&#160;</td>
          <td class="paramname"><em>roadSegment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::ParametricValue const&#160;</td>
          <td class="paramname"><em>parametric_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get borders of a road segment. The road segment is cut at a given parametric offset. </p>
<p>The order of the points within the LaneGeometries are ordered according to the route direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">roadSegment</td><td>the road segment to extract the borders from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parametric_offset</td><td>parametric offset the borders are cut </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8f14ee5e3c8b668eddd7c7925b748c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f14ee5e3c8b668eddd7c7925b748c0">&#9670;&nbsp;</a></span>getECEFBorderOfRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacead_1_1map_1_1lane.html#affbbb4ff457044f17bf7ed620a013a0a">lane::ECEFBorderList</a> ad::map::route::getECEFBorderOfRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get borders of a full route </p>
<p>The order of the points within the LaneGeometries are ordered according to the route direction. The borders of successive road segments are collected in the result vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route to extract the borders from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac60a4c4f63e8cae13ffc24207a229ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60a4c4f63e8cae13ffc24207a229ab7">&#9670;&nbsp;</a></span>getENUBorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1ENUBorder.html">lane::ENUBorder</a> ad::map::route::getENUBorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the enu borders of this lane </p>
<p>Note: The border (left/right edge) will start with the parametric offset given by the lane_interval. </p>

</div>
</div>
<a id="a20f96d43866b112fcf7646c93af22b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f96d43866b112fcf7646c93af22b80">&#9670;&nbsp;</a></span>getENUBorderOfRoadSegment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1ENUBorder.html">lane::ENUBorder</a> ad::map::route::getENUBorderOfRoadSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;&#160;</td>
          <td class="paramname"><em>roadSegment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get borders of a road segment </p>
<p>The order of the points within the LaneGeometries are ordered according to the route direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">roadSegment</td><td>the road segment to extract the borders from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ec8d8257662a6b5c39192ce8237aea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec8d8257662a6b5c39192ce8237aea7">&#9670;&nbsp;</a></span>getENUBorderOfRoadSegment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1ENUBorder.html">lane::ENUBorder</a> ad::map::route::getENUBorderOfRoadSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;&#160;</td>
          <td class="paramname"><em>roadSegment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::ParametricValue const&#160;</td>
          <td class="paramname"><em>parametric_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get borders of a road segment. The road segment is cut at a given parametric offset. </p>
<p>The order of the points within the LaneGeometries are ordered according to the route direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">roadSegment</td><td>the road segment to extract the borders from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parametric_offset</td><td>parametric offset the borders are cut </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f2488ff0e8400f9e4f4588b0878ef63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2488ff0e8400f9e4f4588b0878ef63">&#9670;&nbsp;</a></span>getENUBorderOfRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacead_1_1map_1_1lane.html#a00ad8891bdb4c04eaebad6511ee47829">lane::ENUBorderList</a> ad::map::route::getENUBorderOfRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get borders of a full route </p>
<p>The order of the points within the LaneGeometries are ordered according to the route direction. The borders of successive road segments are collected in the result vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route to extract the borders from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abed34621501e49d81fa4dc0383d9bd5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed34621501e49d81fa4dc0383d9bd5b">&#9670;&nbsp;</a></span>getENUHeadingOfRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classad_1_1map_1_1point_1_1ENUHeading.html">point::ENUHeading</a> ad::map::route::getENUHeadingOfRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1match_1_1Object.html">match::Object</a> const &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the ENU heading of a route at the location of the object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>the object on the route </td></tr>
    <tr><td class="paramname">route</td><td>the route</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classad_1_1map_1_1point_1_1ENUHeading.html" title="DataType ENUHeading.">ad::map::point::ENUHeading(2 * M_PI)</a> if the objects map matched bounding box is not on the route </dd></dl>

</div>
</div>
<a id="a2f8fd91b30c7a4ee2c14da6d208a2e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8fd91b30c7a4ee2c14da6d208a2e72">&#9670;&nbsp;</a></span>getENUProjectedBorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1ENUBorder.html">lane::ENUBorder</a> ad::map::route::getENUProjectedBorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the enu borders of this lane </p>
<p>Note: The border (left/right edge) does not necessarily start/end with the parametric offset given by the lane_interval. Instead this offset is used for the center line and the resulting point is orthogonally projected on the edges to obtain the border </p>

</div>
</div>
<a id="ace048225308a13f5a679a041b170ff0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace048225308a13f5a679a041b170ff0f">&#9670;&nbsp;</a></span>getGeoBorderOfRoadSegment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1GeoBorder.html">lane::GeoBorder</a> ad::map::route::getGeoBorderOfRoadSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;&#160;</td>
          <td class="paramname"><em>roadSegment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get borders of a road segment </p>
<p>The order of the points within the LaneGeometries are ordered according to the route direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">roadSegment</td><td>the road segment to extract the borders from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8422ea51630acb7c61fbd5c461f5014e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8422ea51630acb7c61fbd5c461f5014e">&#9670;&nbsp;</a></span>getGeoBorderOfRoadSegment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1GeoBorder.html">lane::GeoBorder</a> ad::map::route::getGeoBorderOfRoadSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;&#160;</td>
          <td class="paramname"><em>roadSegment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::ParametricValue const&#160;</td>
          <td class="paramname"><em>parametric_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get borders of a road segment. The road segment is cut at a given parametric offset. </p>
<p>The order of the points within the LaneGeometries are ordered according to the route direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">roadSegment</td><td>the road segment to extract the borders from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parametric_offset</td><td>parametric offset the borders are cut </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0346a464faafb784bf2988fa90d3dd68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0346a464faafb784bf2988fa90d3dd68">&#9670;&nbsp;</a></span>getGeoBorderOfRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacead_1_1map_1_1lane.html#a581a2cb5308cc92a81657645c5a9e621">lane::GeoBorderList</a> ad::map::route::getGeoBorderOfRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get borders of a full route </p>
<p>The order of the points within the LaneGeometries are ordered according to the route direction. The borders of successive road segments are collected in the result vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route to extract the borders from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67c0d488cac940da9ca40d2c7b924ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c0d488cac940da9ca40d2c7b924ccc">&#9670;&nbsp;</a></span>getHeadingFeasibility()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">physics::Probability ad::map::route::getHeadingFeasibility </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">route::ConnectingRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>connectingRoute</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the feasibility of the connecting route in respect to the heading which is calculated by multiplying the heading ratings <code>heading_rating_a</code> * <code>heading_rating_b</code>.</dd></dl>
<p>The heading rating of an object in respect to the the connected route is 0.0 if the object heading difference in respect to the connected route is 90° and more 0.5 if it is 45° 1.0 if it is equal</p>
<p>Therefore, the resulting headingFeasibility = 0.25 if both vehicles have a 45° heading delta to their respective route. </p>

</div>
</div>
<a id="a8d6bf193c6cb21a67afbb8638c0eee0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6bf193c6cb21a67afbb8638c0eee0a">&#9670;&nbsp;</a></span>getIntervalStart() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> ad::map::route::getIntervalStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classad_1_1map_1_1lane_1_1LaneId.html">lane::LaneId</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get interval start as ParaPoint for a given lane_id and a given route </p>
<p>throws if lane_id not found in route </p>

</div>
</div>
<a id="a186883c51be80c6e1ddc48c94d8f4dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186883c51be80c6e1ddc48c94d8f4dc2">&#9670;&nbsp;</a></span>getIntervalStart() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> ad::map::route::getIntervalStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>class defining a route interval with one lane </p>
<p>The route interval consists of the id of the lane, the start and end point of lane on the route as TParam. TParam describes a parametric point along the lane geometry. By defining the start and end of the route interval, also a direction of the route is defined ... at least if <code>start</code> and <code>end</code> points differ from each other.</p>
<p>If start == end, the route interval is degenerated and therefore no meaningful route direction can be derived. Only if start != end, checks like <a class="el" href="namespacead_1_1map_1_1route.html#a62e09514926364ca1d27b3fad3c1e164" title="checks if the parametric offset is after the interval">isAfterInterval()</a>, <a class="el" href="namespacead_1_1map_1_1route.html#ace6d1bead83c71d31d77d903c6ea374c" title="checks if the parametric offset is before the interval">isBeforeInterval()</a>, <a class="el" href="namespacead_1_1map_1_1route.html#ad936d14bd3758e54aa5d5255d93a214e" title="checks if the direction of this route interval is positive in respect to the lane geometry">isRouteDirectionPositive()</a>, <a class="el" href="namespacead_1_1map_1_1route.html#affbd5d17635b53d133ac3da20ae68bc6" title="checks if the direction of this route interval is negative in respect to the lane geometry">isRouteDirectionNegative()</a> provide the expected information.</p>
<p>get interval start as ParaPoint </p>

</div>
</div>
<a id="ae93bc20be3049b172aaad13218ed9166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93bc20be3049b172aaad13218ed9166">&#9670;&nbsp;</a></span>getLaneParaPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> ad::map::route::getLaneParaPoint </td>
          <td>(</td>
          <td class="paramtype">physics::ParametricValue const &amp;&#160;</td>
          <td class="paramname"><em>routeParametricOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">route::LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the lane para points in respect to the given route parametric offset </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">routeParametricOffset</td><td>the parametric offset in respect to the route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lane_interval</td><td>the lane_interval to consider, the whole lane interval is considered to be a full segment of a route.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parametric point within the corresponding lane interval in respect to the given route parametric offset. </dd></dl>

</div>
</div>
<a id="aae2678f9b71224d0fb33899237647b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2678f9b71224d0fb33899237647b3c">&#9670;&nbsp;</a></span>getLaneParaPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacead_1_1map_1_1point.html#a61ca5a48026fe858c1f9db0167256fda">point::ParaPointList</a> ad::map::route::getLaneParaPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html">route::RouteParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>routePosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the lane para points in respect to the given route position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">routePosition</td><td>the route position to find </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route to check for the position</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lane segment para points within the corresponding route segment. If the routePosition is not found an empty list is returned. </dd></dl>

</div>
</div>
<a id="afa2dcf35500e9356855d71c7746a744e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2dcf35500e9356855d71c7746a744e">&#9670;&nbsp;</a></span>getLeftECEFEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1ECEFEdge.html">lane::ECEFEdge</a> ad::map::route::getLeftECEFEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get left edge of the lane interval as ECEFEdge </p>
<p>Be aware: Left is in the sense of the lane interval orientation. If the lane interval has negative direction the physical right edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="a537b3772998ed31950e14480be707ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537b3772998ed31950e14480be707ee8">&#9670;&nbsp;</a></span>getLeftEdge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::getLeftEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1lane_1_1ECEFEdge.html">lane::ECEFEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>ecefEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get Left edge of the lane interval as ECEFEdge </p>
<p>Be aware: Left is in the sense of the lane interval orientation. If the lane interval has negative direction the physical right edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="af02627cba57de68234a304193dca5a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02627cba57de68234a304193dca5a79">&#9670;&nbsp;</a></span>getLeftEdge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::getLeftEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1lane_1_1ENUEdge.html">lane::ENUEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>enuEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get Left edge of the lane interval as ENUEdge </p>
<p>Be aware: Left is in the sense of the lane interval orientation. If the lane interval has negative direction the physical right edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="a5b08cf2f803577f89fd0d71d86da35f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b08cf2f803577f89fd0d71d86da35f9">&#9670;&nbsp;</a></span>getLeftEdge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::getLeftEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1lane_1_1GeoEdge.html">lane::GeoEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>geoEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get Left edge of the lane interval as GeoEdge </p>
<p>Be aware: Left is in the sense of the lane interval orientation. If the lane interval has negative direction the physical right edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="abfe1295f8b412c2221f21b0b1d007d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe1295f8b412c2221f21b0b1d007d3c">&#9670;&nbsp;</a></span>getLeftENUEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1ENUEdge.html">lane::ENUEdge</a> ad::map::route::getLeftENUEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get left edge of the lane interval as ENUEdge </p>
<p>Be aware: Left is in the sense of the lane interval orientation. If the lane interval has negative direction the physical right edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="a12440227edad60b5d8dce510f0289257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12440227edad60b5d8dce510f0289257">&#9670;&nbsp;</a></span>getLeftGeoEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1GeoEdge.html">lane::GeoEdge</a> ad::map::route::getLeftGeoEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get left edge of the lane interval as GeoEdge </p>
<p>Be aware: Left is in the sense of the lane interval orientation. If the lane interval has negative direction the physical right edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="a134e5cdd7edf541b2718bf43795f81b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134e5cdd7edf541b2718bf43795f81b1">&#9670;&nbsp;</a></span>getLeftProjectedECEFEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1ECEFEdge.html">lane::ECEFEdge</a> ad::map::route::getLeftProjectedECEFEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get left edge of the lane interval as ECEFEdge using projection to find the start of the edge </p>
<p>Be aware: Left is in the sense of the lane interval orientation. If the lane interval has negative direction the physical right edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="a4edc96cca8f06d57deb0eaafb098aa3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edc96cca8f06d57deb0eaafb098aa3f">&#9670;&nbsp;</a></span>getLeftProjectedEdge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::getLeftProjectedEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1lane_1_1ECEFEdge.html">lane::ECEFEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>ecefEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get Left edge of the lane interval as ECEFEdge using projection to find the start of the edge </p>
<p>Be aware: Left is in the sense of the lane interval orientation. If the lane interval has negative direction the physical right edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="a9831b1f4d7bee73f71420ae5a61b4202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9831b1f4d7bee73f71420ae5a61b4202">&#9670;&nbsp;</a></span>getLeftProjectedEdge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::getLeftProjectedEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1lane_1_1ENUEdge.html">lane::ENUEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>enuEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get Left edge of the lane interval as ENUEdge using projection to find the start of the edge </p>
<p>Be aware: Left is in the sense of the lane interval orientation. If the lane interval has negative direction the physical right edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="a5e92a8d9c2c8e2429def8a41654b2088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e92a8d9c2c8e2429def8a41654b2088">&#9670;&nbsp;</a></span>getLeftProjectedEdge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::getLeftProjectedEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1lane_1_1GeoEdge.html">lane::GeoEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>geoEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get Left edge of the lane interval as GeoEdge using projection to find the start of the edge </p>
<p>Be aware: Left is in the sense of the lane interval orientation. If the lane interval has negative direction the physical right edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="af0dc6f9c4221e3c5cda9753919a9347b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0dc6f9c4221e3c5cda9753919a9347b">&#9670;&nbsp;</a></span>getLeftProjectedENUEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1ENUEdge.html">lane::ENUEdge</a> ad::map::route::getLeftProjectedENUEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get left edge of the lane interval as ENUEdge using projection to find the start of the edge </p>
<p>Be aware: Left is in the sense of the lane interval orientation. If the lane interval has negative direction the physical right edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="a888e887f4b317d5095730d579169ae84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888e887f4b317d5095730d579169ae84">&#9670;&nbsp;</a></span>getLeftProjectedGeoEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1GeoEdge.html">lane::GeoEdge</a> ad::map::route::getLeftProjectedGeoEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get left edge of the lane interval as GeoEdge using projection to find the start of the edge </p>
<p>Be aware: Left is in the sense of the lane interval orientation. If the lane interval has negative direction the physical right edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="a50137f5732ad94fd2c954da527bed61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50137f5732ad94fd2c954da527bed61f">&#9670;&nbsp;</a></span>getProjectedParametricOffsetOnNeighborLane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">physics::ParametricValue ad::map::route::getProjectedParametricOffsetOnNeighborLane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>currentInterval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>neighborInterval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::ParametricValue const &amp;&#160;</td>
          <td class="paramname"><em>parametric_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>project a given parametric position (offset) to the center line of the given neighbor lane </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentInterval</td><td>is the current lane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighborInterval</td><td>is the neighbor lane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parametric_offset</td><td>is the current position that should be projected to the neighbor lane</td></tr>
  </table>
  </dd>
</dl>
<p>Note: If the given neighborInterval is not a neighbor of the currentInterval the function will throw</p>
<dl class="section return"><dt>Returns</dt><dd>Projected position as parametric offset </dd></dl>

</div>
</div>
<a id="a45ae0dfabf5969005a0fe3ec6f8f24ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ae0dfabf5969005a0fe3ec6f8f24ef">&#9670;&nbsp;</a></span>getRightECEFEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1ECEFEdge.html">lane::ECEFEdge</a> ad::map::route::getRightECEFEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get right edge of the lane interval as ECEFEdge </p>
<p>Be aware: Right is in the sense of the lane interval orientation. If the lane interval has negative direction the physical left edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="a845213e4e5636a2a6670735951833b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845213e4e5636a2a6670735951833b20">&#9670;&nbsp;</a></span>getRightEdge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::getRightEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1lane_1_1ECEFEdge.html">lane::ECEFEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>ecefEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get right edge of the lane interval as ECEFEdge </p>
<p>Be aware: Right is in the sense of the lane interval orientation. If the lane interval has negative direction the physical left edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="af5b03afc5d5a696f4eaaf15d3dd974c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b03afc5d5a696f4eaaf15d3dd974c8">&#9670;&nbsp;</a></span>getRightEdge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::getRightEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1lane_1_1ENUEdge.html">lane::ENUEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>enuEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get right edge of the lane interval as ENUEdge </p>
<p>Be aware: Right is in the sense of the lane interval orientation. If the lane interval has negative direction the physical left edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="a6819a9e97c8905b61a5fd1b450ab092d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6819a9e97c8905b61a5fd1b450ab092d">&#9670;&nbsp;</a></span>getRightEdge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::getRightEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1lane_1_1GeoEdge.html">lane::GeoEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>geoEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get right edge of the lane interval as GeoEdge </p>
<p>Be aware: Right is in the sense of the lane interval orientation. If the lane interval has negative direction the physical left edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="af8b8e3bea8053ba7f5e713126534db64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b8e3bea8053ba7f5e713126534db64">&#9670;&nbsp;</a></span>getRightENUEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1ENUEdge.html">lane::ENUEdge</a> ad::map::route::getRightENUEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get right edge of the lane interval as ENUEdge </p>
<p>Be aware: Right is in the sense of the lane interval orientation. If the lane interval has negative direction the physical left edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="a8c5b5e91ec1c2f554675e3c85ebf1252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5b5e91ec1c2f554675e3c85ebf1252">&#9670;&nbsp;</a></span>getRightGeoEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1GeoEdge.html">lane::GeoEdge</a> ad::map::route::getRightGeoEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get right edge of the lane interval as GeoEdge </p>
<p>Be aware: Right is in the sense of the lane interval orientation. If the lane interval has negative direction the physical left edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="aa1f3fae38f9140acb92b961f8eddfb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f3fae38f9140acb92b961f8eddfb64">&#9670;&nbsp;</a></span>getRightProjectedECEFEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1ECEFEdge.html">lane::ECEFEdge</a> ad::map::route::getRightProjectedECEFEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get right edge of the lane interval as ECEFEdge using projection to find the start of the edge </p>
<p>Be aware: Right is in the sense of the lane interval orientation. If the lane interval has negative direction the physical left edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="ae032fd4d27dd29dbfc0280d9e5e8f531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae032fd4d27dd29dbfc0280d9e5e8f531">&#9670;&nbsp;</a></span>getRightProjectedEdge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::getRightProjectedEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1lane_1_1ECEFEdge.html">lane::ECEFEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>ecefEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get right edge of the lane interval as ECEFEdge using projection to find the start of the edge </p>
<p>Be aware: Right is in the sense of the lane interval orientation. If the lane interval has negative direction the physical left edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="a901be85a1d048210ef27de1c1b212970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901be85a1d048210ef27de1c1b212970">&#9670;&nbsp;</a></span>getRightProjectedEdge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::getRightProjectedEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1lane_1_1ENUEdge.html">lane::ENUEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>enuEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get right edge of the lane interval as ENUEdge using projection to find the start of the edge </p>
<p>Be aware: Right is in the sense of the lane interval orientation. If the lane interval has negative direction the physical left edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="a6c832ee5be74b3430dd9f25780096bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c832ee5be74b3430dd9f25780096bd4">&#9670;&nbsp;</a></span>getRightProjectedEdge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::getRightProjectedEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1lane_1_1GeoEdge.html">lane::GeoEdge</a> &amp;&#160;</td>
          <td class="paramname"><em>geoEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get right edge of the lane interval as GeoEdge using projection to find the start of the edge </p>
<p>Be aware: Right is in the sense of the lane interval orientation. If the lane interval has negative direction the physical left edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="a890ecbc7c9ce9eae16d2d8b43fb00af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890ecbc7c9ce9eae16d2d8b43fb00af2">&#9670;&nbsp;</a></span>getRightProjectedENUEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1ENUEdge.html">lane::ENUEdge</a> ad::map::route::getRightProjectedENUEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get right edge of the lane interval as ENUEdge using projection to find the start of the edge </p>
<p>Be aware: Right is in the sense of the lane interval orientation. If the lane interval has negative direction the physical left edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="ad147581cc5434aaffb437c9509f4b69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad147581cc5434aaffb437c9509f4b69a">&#9670;&nbsp;</a></span>getRightProjectedGeoEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1lane_1_1GeoEdge.html">lane::GeoEdge</a> ad::map::route::getRightProjectedGeoEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get right edge of the lane interval as GeoEdge using projection to find the start of the edge </p>
<p>Be aware: Right is in the sense of the lane interval orientation. If the lane interval has negative direction the physical left edge of the underlying lane is returned. Furthermore, the points are ordered in the logical lane interval direction: the first point is at lane interval start and the last one at lane interval end. </p>

</div>
</div>
<a id="a3a2a84a5d47bc4106d00ce46dc800945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2a84a5d47bc4106d00ce46dc800945">&#9670;&nbsp;</a></span>getRouteExpandedTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> ad::map::route::getRouteExpandedTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1route.html#aaae9bcaf2936b1abe025aebd0fcbd77b">RouteCreationMode</a> const&#160;</td>
          <td class="paramname"><em>route_creation_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the input route expanded/narrowed if required</dd></dl>
<p>Internally recreates the route by calling <a class="el" href="namespacead_1_1map_1_1route.html#a3ae2ad49e85cb12962652274ba892257" title="function to append a new lane interval to a road segment list">appendRoadSegmentToRoute()</a> with a new route having the given <code>route_creation_mode</code> applied. </p>

</div>
</div>
<a id="a5fff411498b17437ba2432ca76856cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fff411498b17437ba2432ca76856cfe">&#9670;&nbsp;</a></span>getRouteExpandedToAllNeighborLanes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> ad::map::route::getRouteExpandedToAllNeighborLanes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the input route expanded by all neighbor lanes</dd></dl>
<p>Internally recreates the route by calling <a class="el" href="namespacead_1_1map_1_1route.html#a3ae2ad49e85cb12962652274ba892257" title="function to append a new lane interval to a road segment list">appendRoadSegmentToRoute()</a> with a new route having RouteCreationMode::AllNeighbors </p>

</div>
</div>
<a id="a9d0e75a67039133b0ba8aa02e9c63bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0e75a67039133b0ba8aa02e9c63bf0">&#9670;&nbsp;</a></span>getRouteExpandedToOppositeLanes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> ad::map::route::getRouteExpandedToOppositeLanes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the input route expanded/narrowed by all lanes in opposite driving direction</dd></dl>
<p>Internally recreates the route by calling <a class="el" href="namespacead_1_1map_1_1route.html#a3ae2ad49e85cb12962652274ba892257" title="function to append a new lane interval to a road segment list">appendRoadSegmentToRoute()</a> with a new route having <a class="el" href="namespacead_1_1map_1_1route.html#aaae9bcaf2936b1abe025aebd0fcbd77ba3078ff695395cfdd7f026a80ab57f514">RouteCreationMode::AllRoutableLanes</a> </p>

</div>
</div>
<a id="a3cdcd283975e580d7b97029c3444f27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdcd283975e580d7b97029c3444f27e">&#9670;&nbsp;</a></span>getRouteExpandedToSameDrivingDirectionLanesOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> ad::map::route::getRouteExpandedToSameDrivingDirectionLanesOnly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the input route expanded/narrowed by only lanes in same driving direction</dd></dl>
<p>Internally recreates the route by calling <a class="el" href="namespacead_1_1map_1_1route.html#a3ae2ad49e85cb12962652274ba892257" title="function to append a new lane interval to a road segment list">appendRoadSegmentToRoute()</a> with a new route having <a class="el" href="namespacead_1_1map_1_1route.html#aaae9bcaf2936b1abe025aebd0fcbd77bab51cd2c8724851ff796ff8cbb1cfa645">RouteCreationMode::SameDrivingDirection</a> </p>

</div>
</div>
<a id="a8553cd7f33ea9187575277ad411fae4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8553cd7f33ea9187575277ad411fae4a">&#9670;&nbsp;</a></span>getRouteIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1RouteIterator.html">RouteIterator</a> ad::map::route::getRouteIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html">route::RouteParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>routePosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the route iterator from a given route position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">routePosition</td><td>the route position to find </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route to check for the position</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="structad_1_1map_1_1route_1_1RouteIterator.html" title="struct defining iterator information on a route">RouteIterator</a> pointing to the corresponding route segment. If the routePosition is not found an invalid <a class="el" href="structad_1_1map_1_1route_1_1RouteIterator.html" title="struct defining iterator information on a route">RouteIterator</a> is returned. </dd></dl>

</div>
</div>
<a id="a399f2ab08717a22f52cc1bc3c52cc1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399f2ab08717a22f52cc1bc3c52cc1ec">&#9670;&nbsp;</a></span>getRouteParaPointFromParaPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::getRouteParaPointFromParaPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>para_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html">route::RouteParaPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>routeParaPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the <a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html" title="DataType RouteParaPoint.">RouteParaPoint</a> for a given ParaPoint and <a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html" title="DataType FullRoute.">FullRoute</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">para_point</td><td>is the point under consideration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">routeParaPoint</td><td>the converted result</td></tr>
  </table>
  </dd>
</dl>
<p>returns <code>true</code> if the para_point was found in the route </p>

</div>
</div>
<a id="aa93e130d9c2e40045e9c5dd8ca68987e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93e130d9c2e40045e9c5dd8ca68987e">&#9670;&nbsp;</a></span>getRouteSection() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> ad::map::route::getRouteSection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a> const &amp;&#160;</td>
          <td class="paramname"><em>currentLane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::Distance const &amp;&#160;</td>
          <td class="paramname"><em>distanceFront</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::Distance const &amp;&#160;</td>
          <td class="paramname"><em>distanceEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14ec">RouteSectionCreationMode</a> const&#160;</td>
          <td class="paramname"><em>routeSectionCreationMode</em> = <code><a class="el" href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14eca74984df073bdd6adc2d642e66956e1c3">RouteSectionCreationMode::SingleLane</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a section of the route that is within the given distance around the given LanePoint. </p>
<p>This section will contain the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> that the center point is located at and all the predecessors &amp; successors of this lane up to the given distances or the start / end of the route The length of the resulting route will be distanceFront + distanceEnd except the start / end of the route is within the delta region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentLane</td><td>specifying the origin of the delta section as <a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html" title="struct defining the result type of findWaypoint() and findNearestWaypoint()">FindWaypointResult</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>to be included in the delta region towards begin of the route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>to be included in the delta region towards end of the route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">the</td><td>route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">routeSectionCreationMode</td><td>the creation mode for the route section.</td></tr>
  </table>
  </dd>
</dl>
<p>return the extracted route (will be empty if the center_point is not found in the route)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the route is inconsistent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5ae53b920b4483461da84a00768f643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ae53b920b4483461da84a00768f643">&#9670;&nbsp;</a></span>getRouteSection() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> ad::map::route::getRouteSection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1match_1_1Object.html">match::Object</a> const &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14ec">RouteSectionCreationMode</a> const&#160;</td>
          <td class="paramname"><em>routeSectionCreationMode</em> = <code><a class="el" href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14eca74984df073bdd6adc2d642e66956e1c3">RouteSectionCreationMode::SingleLane</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a section of the route that is around the given object. </p>
<p>This section will contain the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> that the center point of the object is located at and all the predecessors &amp; successors of this lane up to half of the objects length or the start / end of the route The length of the resulting route will be object's length except the start / end of the route is within the delta region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>specifying the object as the origin and dimension of the delta section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">the</td><td>route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">routeSectionCreationMode</td><td>the creation mode for the route section.</td></tr>
  </table>
  </dd>
</dl>
<p>return the extracted route (will be empty if the object is not found in the route)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the route is inconsistent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34486bfa4efa7849e74b8f51f74204e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34486bfa4efa7849e74b8f51f74204e6">&#9670;&nbsp;</a></span>getRouteSection() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> ad::map::route::getRouteSection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>center_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::Distance const &amp;&#160;</td>
          <td class="paramname"><em>distanceFront</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::Distance const &amp;&#160;</td>
          <td class="paramname"><em>distanceEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14ec">RouteSectionCreationMode</a> const&#160;</td>
          <td class="paramname"><em>routeSectionCreationMode</em> = <code><a class="el" href="namespacead_1_1map_1_1route.html#a5993e33e6ed864f1e1ad2a9eecbd14eca74984df073bdd6adc2d642e66956e1c3">RouteSectionCreationMode::SingleLane</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a section of the route that is within the given distance around the given LanePoint. </p>
<p>This section will contain the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> that the center point is located at and all the predecessors &amp; successors of this lane up to the given distances or the start / end of the route The length of the resulting route will be distanceFront + distanceEnd except the start / end of the route is within the delta region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">center_point</td><td>specifying the origin of the delta section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>to be included in the delta region towards begin of the route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>to be included in the delta region towards end of the route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">the</td><td>route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">routeSectionCreationMode</td><td>the creation mode for the route section.</td></tr>
  </table>
  </dd>
</dl>
<p>return the extracted route (will be empty if the center_point is not found in the route)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the route is inconsistent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a614593c9a3a4398ca241939a3fe93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a614593c9a3a4398ca241939a3fe93b">&#9670;&nbsp;</a></span>getSignedDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">physics::ParametricValue ad::map::route::getSignedDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the signed parametric physics::Distance between two parametric points respecting the lane_interval's direction </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;</td><td>0, if the <code>first</code> point is before the <code>second</code> point within the interval </td></tr>
    <tr><td class="paramname">&lt;</td><td>0, if the <code>second</code> point is before the <code>first</code> point within the interval </td></tr>
    <tr><td class="paramname">=</td><td>0, if both are equal</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the parametric points are not referring to the landId </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16f0266324051ed94952734633231a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f0266324051ed94952734633231a4a">&#9670;&nbsp;</a></span>getUnsignedDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">physics::ParametricValue ad::map::route::getUnsignedDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the unsigned parametric physics::Distance between two parametric points </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">|</td><td><code>first.parametric_offset</code> - <code>second.parametric_offset</code> | </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the parametric points are not referring to the landId </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4a42981a92717fcc1d81e610256473f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a42981a92717fcc1d81e610256473f">&#9670;&nbsp;</a></span>intersectionOnRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a> ad::map::route::intersectionOnRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classad_1_1map_1_1intersection_1_1Intersection.html">intersection::Intersection</a> const &amp;&#160;</td>
          <td class="paramname"><em>intersection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find waypoint on the route containing a lane of the given intersection </p>
<p>This function will return the nearest waypoint along the route</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">intersection</td><td>which inner lanes should be searched for within the route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route to search in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>waypoint result containing an iterator pointing to the route segment the lane of the intersection is part of and the corresponding route interval having that lane id. If multiple are matching the one nearest the begin of the route is selected. </dd></dl>

</div>
</div>
<a id="a62e09514926364ca1d27b3fad3c1e164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e09514926364ca1d27b3fad3c1e164">&#9670;&nbsp;</a></span>isAfterInterval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::isAfterInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::ParametricValue const&#160;</td>
          <td class="paramname"><em>parametric_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks if the parametric offset is after the interval </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parametric_offset</td><td>parametric offset to be checked against the route interval</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if given parametric offset is after the interval Be aware: if the route interval is degenerated <a class="el" href="namespacead_1_1map_1_1route.html#a62e09514926364ca1d27b3fad3c1e164" title="checks if the parametric offset is after the interval">isAfterInterval()</a> and <a class="el" href="namespacead_1_1map_1_1route.html#ace6d1bead83c71d31d77d903c6ea374c" title="checks if the parametric offset is before the interval">isBeforeInterval()</a> return the same value </dd></dl>

</div>
</div>
<a id="ab8d95666b3449f27c3f2660f0d4d8df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d95666b3449f27c3f2660f0d4d8df9">&#9670;&nbsp;</a></span>isAfterInterval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::isAfterInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks if the point is after the interval </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>parametric point to be checked against the route interval</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if LaneId matches and TParam of the given <code>point</code> is after the interval Be aware: if the route interval is degenerated <a class="el" href="namespacead_1_1map_1_1route.html#a62e09514926364ca1d27b3fad3c1e164" title="checks if the parametric offset is after the interval">isAfterInterval()</a> and <a class="el" href="namespacead_1_1map_1_1route.html#ace6d1bead83c71d31d77d903c6ea374c" title="checks if the parametric offset is before the interval">isBeforeInterval()</a> return the same value ( point != end ) </dd></dl>

</div>
</div>
<a id="ace6d1bead83c71d31d77d903c6ea374c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6d1bead83c71d31d77d903c6ea374c">&#9670;&nbsp;</a></span>isBeforeInterval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::isBeforeInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::ParametricValue const&#160;</td>
          <td class="paramname"><em>parametric_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks if the parametric offset is before the interval </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parametric_offset</td><td>parametric offset to be checked against the route interval</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if parametric offset is before the interval Be aware: if the route interval is degenerated <a class="el" href="namespacead_1_1map_1_1route.html#a62e09514926364ca1d27b3fad3c1e164" title="checks if the parametric offset is after the interval">isAfterInterval()</a> and <a class="el" href="namespacead_1_1map_1_1route.html#ace6d1bead83c71d31d77d903c6ea374c" title="checks if the parametric offset is before the interval">isBeforeInterval()</a> return the same value </dd></dl>

</div>
</div>
<a id="a8221e803c0f6a14b0c7ff97db6f29669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8221e803c0f6a14b0c7ff97db6f29669">&#9670;&nbsp;</a></span>isBeforeInterval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::isBeforeInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks if the point is before the interval </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>parametric point to be checked against the route interval</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if LaneId matches and TParam of the given <code>point</code> is before the interval Be aware: if the route interval is degenerated <a class="el" href="namespacead_1_1map_1_1route.html#a62e09514926364ca1d27b3fad3c1e164" title="checks if the parametric offset is after the interval">isAfterInterval()</a> and <a class="el" href="namespacead_1_1map_1_1route.html#ace6d1bead83c71d31d77d903c6ea374c" title="checks if the parametric offset is before the interval">isBeforeInterval()</a> return the same value ( point != start ) </dd></dl>

</div>
</div>
<a id="a6ba66fce67fc89973d04dd2911207f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba66fce67fc89973d04dd2911207f79">&#9670;&nbsp;</a></span>isConnectedRoutePartOfAnIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::isConnectedRoutePartOfAnIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">route::ConnectingRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>connectingRoute</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the connecting route contains road segments which are part of an intersection </dd></dl>

</div>
</div>
<a id="a2b56d6c9116de25f143ffa162b7f0553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b56d6c9116de25f143ffa162b7f0553">&#9670;&nbsp;</a></span>isDegenerated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::isDegenerated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks if the interval is degenerated </p>
<p>The interval is degenerated if start and end of the interval are equal. In such a case no meaningful information on route direction is possible.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the interval is degenerated: start == end </dd></dl>

</div>
</div>
<a id="a768a82ce9d96a1bfdc3516a57e87d915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768a82ce9d96a1bfdc3516a57e87d915">&#9670;&nbsp;</a></span>isEndOfInterval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::isEndOfInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks if the point marks the end of the interval </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>parametric point to be checked against the route interval end</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if LaneId and TParam at end of this matches the given <code>point</code> </dd></dl>

</div>
</div>
<a id="a5dd4f807c719eae6e94596407d608c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd4f807c719eae6e94596407d608c8c">&#9670;&nbsp;</a></span>isObjectHeadingInRouteDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::isObjectHeadingInRouteDirection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1match_1_1Object.html">match::Object</a> const &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare the ENU heading of the route at the location of the object with the ENU heading of the object </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the difference between object heading and route heading at the object position is not larger than 90° </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the objects map matched bounding box is not on the route </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affbd5d17635b53d133ac3da20ae68bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbd5d17635b53d133ac3da20ae68bc6">&#9670;&nbsp;</a></span>isRouteDirectionNegative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::isRouteDirectionNegative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks if the direction of this route interval is negative in respect to the lane geometry </p>
<dl class="section return"><dt>Returns</dt><dd>!isRouteDirectionPositive() </dd></dl>

</div>
</div>
<a id="ad936d14bd3758e54aa5d5255d93a214e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad936d14bd3758e54aa5d5255d93a214e">&#9670;&nbsp;</a></span>isRouteDirectionPositive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::isRouteDirectionPositive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the direction of this route interval is positive in respect to the lane geometry </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the parametric points follow: start &lt; end </dd>
<dd>
<code><a class="el" href="namespacead_1_1map_1_1lane.html#a52aab121d462c7ae7577d6899a58ea97">lane::isLaneDirectionPositive</a></code>(lane_interval.lane_id) ^ wrong_way if start == end (degenerated interval uses wrong way flag to determine the route direction) </dd></dl>

</div>
</div>
<a id="a48949054ec50cd778d3c75c853180163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48949054ec50cd778d3c75c853180163">&#9670;&nbsp;</a></span>isStartOfInterval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::isStartOfInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks if the point marks the start of the interval </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>parametric point to be checked against the route interval start</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if LaneId and TParam at start of this matches the given <code>point</code> </dd></dl>

</div>
</div>
<a id="a3d3a4c6dc5e9d4d8da2d12ab1057d482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3a4c6dc5e9d4d8da2d12ab1057d482">&#9670;&nbsp;</a></span>isWithinInterval() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::isWithinInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::ParametricValue const &amp;&#160;</td>
          <td class="paramname"><em>parametric_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks if the parametric offset is within the interval </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parametric_offset</td><td>parametric offset to be checked against the route interval</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if parametric offset is within the interval </dd></dl>

</div>
</div>
<a id="a9c00e1b6ae54389f870866725d852e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c00e1b6ae54389f870866725d852e43">&#9670;&nbsp;</a></span>isWithinInterval() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::isWithinInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks if the point is within the interval </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>parametric point to be checked against the route interval</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if LaneId matches and TParam of the given <code>point</code> is within the interval </dd></dl>

</div>
</div>
<a id="a62c051c129fff58bab0518e682eb7a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c051c129fff58bab0518e682eb7a9f">&#9670;&nbsp;</a></span>isWithinInterval() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::isWithinInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;&#160;</td>
          <td class="paramname"><em>roadSegment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if the point is within the roadSegment </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>parametric point to be checked against the road segment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the point is within one of the segments lane intervals </dd></dl>

</div>
</div>
<a id="aff590f45f2617c0e840cdabb96b97cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff590f45f2617c0e840cdabb96b97cf1">&#9670;&nbsp;</a></span>objectOnRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a> ad::map::route::objectOnRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1match_1_1MapMatchedObjectBoundingBox.html">match::MapMatchedObjectBoundingBox</a> const &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find nearest waypoint on the route containing the given mapmatched bounding box </p>
<p>This function will return the nearest waypoint along the route</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>which position which should be searched for within the route </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>the route to search in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>waypoint result containing an iterator pointing to the route segment the lane of the position is part of and the corresponding route interval having that lane id. If multiple are matching the one nearest the begin of the route is selected. </dd></dl>

</div>
</div>
<a id="aaf4e6cd1476293dc7a59b9e50f3cf565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4e6cd1476293dc7a59b9e50f3cf565">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; ad::map::route::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">ConnectingRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>standard ostream operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The output stream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_value</td><td><a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html" title="DataType ConnectingRoute.">ConnectingRoute</a> value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream object. </dd></dl>

</div>
</div>
<a id="a91ba080db4e287e95c1e881bba7cc984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ba080db4e287e95c1e881bba7cc984">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; ad::map::route::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1route.html#a19ef80d84e69ba2770b30d81e9029aa8">ConnectingRouteType</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>standard ostream operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The output stream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>ConnectingRouteType value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream object. </dd></dl>

</div>
</div>
<a id="ace96c75c23a44e45465450e80ba1ee27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace96c75c23a44e45465450e80ba1ee27">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; ad::map::route::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>standard ostream operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The output stream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_value</td><td><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html" title="DataType FullRoute.">FullRoute</a> value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream object. </dd></dl>

</div>
</div>
<a id="a89319989e9eedd5535289a918a3b17ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89319989e9eedd5535289a918a3b17ac">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; ad::map::route::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1route.html#ab046615abf5d3c8c412d213a61670383">LaneChangeDirection</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>standard ostream operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The output stream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>LaneChangeDirection value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream object. </dd></dl>

</div>
</div>
<a id="aec8d23f814c6babd8cff3441d50d958a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8d23f814c6babd8cff3441d50d958a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; ad::map::route::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>standard ostream operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The output stream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_value</td><td><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream object. </dd></dl>

</div>
</div>
<a id="a7bb1ae8d0fbf7d8a7cb2f4e86eba3c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb1ae8d0fbf7d8a7cb2f4e86eba3c45">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; ad::map::route::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneSegment.html">LaneSegment</a> const &amp;&#160;</td>
          <td class="paramname"><em>_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>standard ostream operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The output stream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_value</td><td><a class="el" href="structad_1_1map_1_1route_1_1LaneSegment.html" title="DataType LaneSegment.">LaneSegment</a> value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream object. </dd></dl>

</div>
</div>
<a id="ab9e3b9124637a8f4369539897aa0e588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e3b9124637a8f4369539897aa0e588">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; ad::map::route::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> const &amp;&#160;</td>
          <td class="paramname"><em>_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>standard ostream operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The output stream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_value</td><td><a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html" title="DataType RoadSegment.">RoadSegment</a> value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream object. </dd></dl>

</div>
</div>
<a id="a5f7f8bdbc65c906b47488f98df12fea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7f8bdbc65c906b47488f98df12fea4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; ad::map::route::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1route.html#aaae9bcaf2936b1abe025aebd0fcbd77b">RouteCreationMode</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>standard ostream operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The output stream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>RouteCreationMode value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream object. </dd></dl>

</div>
</div>
<a id="a1bf173775f54df387716dd67d404ccc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf173775f54df387716dd67d404ccc9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; ad::map::route::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html">RouteParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>standard ostream operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>The output stream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_value</td><td><a class="el" href="structad_1_1map_1_1route_1_1RouteParaPoint.html" title="DataType RouteParaPoint.">RouteParaPoint</a> value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream object. </dd></dl>

</div>
</div>
<a id="a6371094606526d93e480e3235d78b48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6371094606526d93e480e3235d78b48d">&#9670;&nbsp;</a></span>overlapsInterval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::overlapsInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks if the two lane intervals overlap with each other </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> to be checked against this lane interval</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if intervals overlap </dd></dl>

</div>
</div>
<a id="af94a3eb9d6dec5ca4aca73d2ae072683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94a3eb9d6dec5ca4aca73d2ae072683">&#9670;&nbsp;</a></span>overlapsInterval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ad::map::route::overlapsInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::ParametricRange const &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks if the range overlaps with the interval </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>parametric range to be checked against the route interval</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if range overlaps with the interval </dd></dl>

</div>
</div>
<a id="aae0b1ec8e08ec519f70e0eb31a9be14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0b1ec8e08ec519f70e0eb31a9be14d">&#9670;&nbsp;</a></span>restrictIntervalFromBegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> ad::map::route::restrictIntervalFromBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::Distance const &amp;&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restrict length of the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> to a given physics::Distance from start. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lane_interval</td><td>the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> that should be restricted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">physics::Distance</td><td>the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> should be restricted to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting shortened <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a></dd></dl>
<p>If physics::Distance is bigger then the length of the interval. Resulting <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> is the input Interval. </p>

</div>
</div>
<a id="a9514a567c48c09bd3e9402a20e463827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9514a567c48c09bd3e9402a20e463827">&#9670;&nbsp;</a></span>shortenIntervalFromBegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> ad::map::route::shortenIntervalFromBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::Distance const &amp;&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shorten the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> about a given physics::Distance. Will remove at the begin of the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">the</td><td><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> that should be shortened </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">physics::Distance</td><td>the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> should be shortened</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting shortened <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a></dd></dl>
<p>If physics::Distance is bigger then the length of the interval. Resulting length will be zero. LaneInterval.start = LaneInterval.end </p>

</div>
</div>
<a id="ad3675ff33b7eef11d5d96312d827a027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3675ff33b7eef11d5d96312d827a027">&#9670;&nbsp;</a></span>shortenIntervalFromEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> ad::map::route::shortenIntervalFromEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html">LaneInterval</a> const &amp;&#160;</td>
          <td class="paramname"><em>lane_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::Distance const &amp;&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shorten the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> about a given physics::Distance. Will remove at the end of the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lane_interval</td><td>the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> that should be shortened </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">physics::Distance</td><td>the <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a> should be shortened</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting shortened <a class="el" href="structad_1_1map_1_1route_1_1LaneInterval.html" title="DataType LaneInterval.">LaneInterval</a></dd></dl>
<p>If physics::Distance is bigger then the length of the interval. Resulting length will be zero. LaneInterval.end = LaneInterval.start </p>

</div>
</div>
<a id="a610a706b502987b014c27d969e67f63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610a706b502987b014c27d969e67f63a">&#9670;&nbsp;</a></span>shortenRoute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822">ShortenRouteResult</a> ad::map::route::shortenRoute </td>
          <td>(</td>
          <td class="paramtype">const physics::Distance &amp;&#160;</td>
          <td class="paramname"><em>length_to_shorten</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670">ShortenRouteMode</a> const&#160;</td>
          <td class="paramname"><em>shortenRouteMode</em> = <code><a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670a960b44c579bc2f6818d2daaf9e4c16f0">ShortenRouteMode::Normal</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>follow the route by the given length </p>
<p>Overloaded version of <a class="el" href="namespacead_1_1map_1_1route.html#a2d11559f11b6e58e1fc13ac89a9a9ec3" title="follow the route up to a certain position and shorten the route accordingly">shortenRoute()</a> allow the distance to be given explicitly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>route the route to be shortened </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length_to_shorten</td><td>the length the route should be shortened from the begin </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shortenRouteMode</td><td>the operation mode for this function (default: <a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670a960b44c579bc2f6818d2daaf9e4c16f0">ShortenRouteMode::Normal</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a66d02c2f8a582446f8dd8752366002b5">ShortenRouteResult::Succeeded</a>,SucceededBeforeRoute::SucceededBeforeRoute</td><td>if the shortening request was accepted resulting in a valid route. </td></tr>
    <tr><td class="paramname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a4b0c532564b19e471cdc04ca7ba03c4c">ShortenRouteResult::SucceededRouteEmpty</a></td><td>if the shortening request was accepted resulting in an empty route (i.e. end of route just crossed). </td></tr>
    <tr><td class="paramname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a02740addb165a62ace58585fe7c8644d">ShortenRouteResult::FailedRouteEmpty</a></td><td>if the shortening failed and resulting route is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afff99d71ff5a033ebae01bea53b88f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff99d71ff5a033ebae01bea53b88f91">&#9670;&nbsp;</a></span>shortenRoute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822">ShortenRouteResult</a> ad::map::route::shortenRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html">FindWaypointResult</a> const &amp;&#160;</td>
          <td class="paramname"><em>findWaypointResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670">ShortenRouteMode</a> const&#160;</td>
          <td class="paramname"><em>shortenRouteMode</em> = <code><a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670a960b44c579bc2f6818d2daaf9e4c16f0">ShortenRouteMode::Normal</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>follow the route until the provided <a class="el" href="structad_1_1map_1_1route_1_1FindWaypointResult.html" title="struct defining the result type of findWaypoint() and findNearestWaypoint()">FindWaypointResult</a> </p>
<p>Overloaded version of <a class="el" href="namespacead_1_1map_1_1route.html#a2d11559f11b6e58e1fc13ac89a9a9ec3" title="follow the route up to a certain position and shorten the route accordingly">shortenRoute()</a> allow the waypoint result to be given explicitly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>route the route to be shortened </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length_to_shorten</td><td>the length the route should be shortened from the begin </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shortenRouteMode</td><td>the operation mode for this function (default: <a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670a960b44c579bc2f6818d2daaf9e4c16f0">ShortenRouteMode::Normal</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a66d02c2f8a582446f8dd8752366002b5">ShortenRouteResult::Succeeded</a>,SucceededBeforeRoute::SucceededBeforeRoute</td><td>if the shortening request was accepted resulting in a valid route. </td></tr>
    <tr><td class="paramname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a4b0c532564b19e471cdc04ca7ba03c4c">ShortenRouteResult::SucceededRouteEmpty</a></td><td>if the shortening request was accepted resulting in an empty route (i.e. end of route just crossed). </td></tr>
    <tr><td class="paramname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a02740addb165a62ace58585fe7c8644d">ShortenRouteResult::FailedRouteEmpty</a></td><td>if the shortening failed and resulting route is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d11559f11b6e58e1fc13ac89a9a9ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d11559f11b6e58e1fc13ac89a9a9ec3">&#9670;&nbsp;</a></span>shortenRoute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822">ShortenRouteResult</a> ad::map::route::shortenRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1point_1_1ParaPoint.html">point::ParaPoint</a> const &amp;&#160;</td>
          <td class="paramname"><em>currentPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670">ShortenRouteMode</a> const&#160;</td>
          <td class="paramname"><em>shortenRouteMode</em> = <code><a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670a960b44c579bc2f6818d2daaf9e4c16f0">ShortenRouteMode::Normal</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>follow the route up to a certain position and shorten the route accordingly </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentPosition</td><td>the position which should mark the start of the route after shortening </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>route the route to be shortened </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shortenRouteMode</td><td>the operation mode for this function (default: <a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670a960b44c579bc2f6818d2daaf9e4c16f0">ShortenRouteMode::Normal</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a66d02c2f8a582446f8dd8752366002b5">ShortenRouteResult::Succeeded</a>,SucceededBeforeRoute::SucceededBeforeRoute</td><td>if the shortening request was accepted resulting in a valid route. </td></tr>
    <tr><td class="paramname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a4b0c532564b19e471cdc04ca7ba03c4c">ShortenRouteResult::SucceededRouteEmpty</a></td><td>if the shortening request was accepted resulting in an empty route (i.e. end of route just crossed). </td></tr>
    <tr><td class="paramname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a02740addb165a62ace58585fe7c8644d">ShortenRouteResult::FailedRouteEmpty</a></td><td>if the shortening failed and resulting route is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c574bba440d395d9d9036a39a949f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c574bba440d395d9d9036a39a949f98">&#9670;&nbsp;</a></span>shortenRoute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822">ShortenRouteResult</a> ad::map::route::shortenRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1point.html#a61ca5a48026fe858c1f9db0167256fda">point::ParaPointList</a> const &amp;&#160;</td>
          <td class="paramname"><em>currentPositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670">ShortenRouteMode</a> const&#160;</td>
          <td class="paramname"><em>shortenRouteMode</em> = <code><a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670a960b44c579bc2f6818d2daaf9e4c16f0">ShortenRouteMode::Normal</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>follow the route up to a certain position and shorten the route accordingly </p>
<p>Overloaded version of <a class="el" href="namespacead_1_1map_1_1route.html#a2d11559f11b6e58e1fc13ac89a9a9ec3" title="follow the route up to a certain position and shorten the route accordingly">shortenRoute()</a> allow the position to be a vector of positions to consider. If multiple of the positions were actually present within the route, the one is selected providing the longest resulting route.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentPositions</td><td>the vector of positions which should mark the start of the route after shortening </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>route the route to be shortened </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shortenRouteMode</td><td>the operation mode for this function (default: <a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670a960b44c579bc2f6818d2daaf9e4c16f0">ShortenRouteMode::Normal</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a66d02c2f8a582446f8dd8752366002b5">ShortenRouteResult::Succeeded</a>,SucceededBeforeRoute::SucceededBeforeRoute</td><td>if the shortening request was accepted resulting in a valid route. </td></tr>
    <tr><td class="paramname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a4b0c532564b19e471cdc04ca7ba03c4c">ShortenRouteResult::SucceededRouteEmpty</a></td><td>if the shortening request was accepted resulting in an empty route (i.e. end of route just crossed). </td></tr>
    <tr><td class="paramname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a02740addb165a62ace58585fe7c8644d">ShortenRouteResult::FailedRouteEmpty</a></td><td>if the shortening failed and resulting route is empty.</td></tr>
  </table>
  </dd>
</dl>
<p>Overloaded version of <a class="el" href="namespacead_1_1map_1_1route.html#a2d11559f11b6e58e1fc13ac89a9a9ec3" title="follow the route up to a certain position and shorten the route accordingly">shortenRoute()</a> allow the position to be a list of mapmatched positions to consider. If multiple of the positions were actually present within the route, the one is selected providing the longest resulting route.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapMatchedPositions</td><td>the map matched positions which should mark the start of the route after shortening </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>route the route to be shortened </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shortenRouteMode</td><td>the operation mode for this function (default: <a class="el" href="namespacead_1_1map_1_1route.html#a35ee85c81b9b35fd5a360e296480c670a960b44c579bc2f6818d2daaf9e4c16f0">ShortenRouteMode::Normal</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a66d02c2f8a582446f8dd8752366002b5">ShortenRouteResult::Succeeded</a>,SucceededBeforeRoute::SucceededBeforeRoute</td><td>if the shortening request was accepted resulting in a valid route. </td></tr>
    <tr><td class="paramname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a4b0c532564b19e471cdc04ca7ba03c4c">ShortenRouteResult::SucceededRouteEmpty</a></td><td>if the shortening request was accepted resulting in an empty route (i.e. end of route just crossed). </td></tr>
    <tr><td class="paramname"><a class="el" href="namespacead_1_1map_1_1route.html#a7061e80e6b9053968633f62a437e2822a02740addb165a62ace58585fe7c8644d">ShortenRouteResult::FailedRouteEmpty</a></td><td>if the shortening failed and resulting route is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4eabef74048da7168df8941310e5dede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eabef74048da7168df8941310e5dede">&#9670;&nbsp;</a></span>shortenRouteToDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::shortenRouteToDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">route::FullRoute</a> &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const physics::Distance &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1route.html#aaded03d451bb5ec6e0a6a6a895d081de">ShortenRouteToDistanceMode</a> const&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespacead_1_1map_1_1route.html#aaded03d451bb5ec6e0a6a6a895d081deaad20191b579063ba3dd57c9ae79fa74e">ShortenRouteToDistanceMode::DontCutIntersection</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shorten the route from the end to have at maximum the given length </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>route the route to check and to shorten at the end </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the maximum length @pramm[in] mode: how should intersections be handled on shortening (default: <a class="el" href="namespacead_1_1map_1_1route.html#aaded03d451bb5ec6e0a6a6a895d081deaad20191b579063ba3dd57c9ae79fa74e">ShortenRouteToDistanceMode::DontCutIntersection</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe49da893591a3c153a4eae8ae9b3474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe49da893591a3c153a4eae8ae9b3474">&#9670;&nbsp;</a></span>shortenSegmentFromBegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::shortenSegmentFromBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> &amp;&#160;</td>
          <td class="paramname"><em>roadSegment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::Distance const &amp;&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shorten the provided road segment by a certain distance from the begin. </p>
<p>The intervals of the segment are shortened as described in <a class="el" href="namespacead_1_1map_1_1route.html#a9514a567c48c09bd3e9402a20e463827" title="shorten the LaneInterval about a given physics::Distance. Will remove at the begin of the LaneInterva...">shortenIntervalFromBegin()</a></p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the roadSegment is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01d4acb6f7555cd1008e596c25395e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d4acb6f7555cd1008e596c25395e21">&#9670;&nbsp;</a></span>shortenSegmentFromEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad::map::route::shortenSegmentFromEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1RoadSegment.html">RoadSegment</a> &amp;&#160;</td>
          <td class="paramname"><em>roadSegment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physics::Distance const &amp;&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shorten the provided road segment by a certain distance from the end. </p>
<p>The intervals of the segment are shortened as described in <a class="el" href="namespacead_1_1map_1_1route.html#ad3675ff33b7eef11d5d96312d827a027" title="shorten the LaneInterval about a given physics::Distance. Will remove at the end of the LaneInterval">shortenIntervalFromEnd()</a></p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the roadSegment is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07f2304ab78c97755c0c30c86ebef929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f2304ab78c97755c0c30c86ebef929">&#9670;&nbsp;</a></span>signedDistanceToLane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">physics::Distance ad::map::route::signedDistanceToLane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classad_1_1map_1_1lane_1_1LaneId.html">lane::LaneId</a> const &amp;&#160;</td>
          <td class="paramname"><em>checkLaneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1FullRoute.html">FullRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacead_1_1map_1_1match.html#aaed86807265fc30096de4c1e809f715c">match::MapMatchedPositionConfidenceList</a> const &amp;&#160;</td>
          <td class="paramname"><em>mapMatchedPositions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the signed distance to a lane w.r.t to a given route (direction) for the map matched positions </p>
<p>This check searches the mapMatchedPositions for the given <em>checkLaneId</em> and returns a signed distance value to the lane.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">checkLaneId</td><td>the lane id to find </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">route</td><td>in which the lane should be in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapMatchedPositions</td><td>the map matched positions to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: If not part of the mapMatchedPositions: distance = std::numeric_limits&lt;physics::Distance&gt;::max() If it's found and map matched type is:<ul>
<li>map matched position is on the lane: distance = 0</li>
<li>map matched position is left of lane: distance &lt; 0</li>
<li>map matched position is right of lane: distance &gt; 0</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the lane is not found inside the route </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a6da2fdd5dde0e95432c7361d5011d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6da2fdd5dde0e95432c7361d5011d4">&#9670;&nbsp;</a></span>swapConnectingRouteObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">route::ConnectingRoute</a> ad::map::route::swapConnectingRouteObjects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structad_1_1map_1_1route_1_1ConnectingRoute.html">route::ConnectingRoute</a> const &amp;&#160;</td>
          <td class="paramname"><em>connectingRoute</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a connecting route with swapped objects </p>
<p>route_a elements become route_b elements and vice-versa </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
